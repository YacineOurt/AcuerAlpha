{"ast":null,"code":"import 'core-js/modules/es.object.keys.js';\nimport 'core-js/modules/es.symbol.js';\nimport 'core-js/modules/es.array.filter.js';\nimport 'core-js/modules/es.object.get-own-property-descriptor.js';\nimport 'core-js/modules/es.object.get-own-property-descriptors.js';\nimport 'core-js/modules/es.object.define-properties.js';\nimport 'core-js/modules/es.object.define-property.js';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport 'core-js/modules/es.object.to-string.js';\nimport 'core-js/modules/es.promise.js';\nimport 'core-js/modules/es.array.is-array.js';\nimport 'core-js/modules/web.timers.js';\nimport 'core-js/modules/es.array.for-each.js';\nimport 'core-js/modules/web.dom-collections.for-each.js';\nimport 'core-js/modules/es.array.map.js';\nimport 'core-js/modules/es.function.bind.js';\nimport { v4 } from 'uuid';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport 'core-js/modules/es.array.iterator.js';\nimport 'core-js/modules/es.map.js';\nimport 'core-js/modules/es.string.iterator.js';\nimport 'core-js/modules/web.dom-collections.iterator.js';\nimport 'core-js/modules/es.array.from.js';\nimport 'core-js/modules/es.array.includes.js';\nimport 'core-js/modules/es.string.includes.js';\nimport 'core-js/modules/es.object.values.js';\nimport 'core-js/modules/es.array.find.js';\nimport 'core-js/modules/es.array.concat.js';\nimport 'core-js/modules/es.regexp.exec.js';\nimport 'core-js/modules/es.string.split.js';\nimport 'core-js/modules/es.array.join.js';\nimport 'core-js/modules/es.date.to-string.js';\nimport 'core-js/modules/es.regexp.to-string.js';\nimport 'core-js/modules/es.string.match.js';\nimport 'core-js/modules/es.array.reduce.js';\nimport 'core-js/modules/es.number.is-nan.js';\nimport 'core-js/modules/es.number.constructor.js';\nimport 'core-js/modules/es.number.parse-float.js';\nimport 'core-js/modules/es.set.js';\nimport 'core-js/modules/es.array.index-of.js';\nimport 'core-js/modules/es.string.trim.js';\nimport dayjs from 'dayjs';\nimport quarterOfYear from 'dayjs/plugin/quarterOfYear';\nimport en from 'dayjs/locale/en';\nimport { fromPairs, toPairs, equals, clone, indexBy, prop, pipe, map, filter, reduce, minBy, maxBy, flatten, pluck, mergeDeepLeft, mergeAll, uniq, dropLast, groupBy, unnest as unnest$1 } from 'ramda';\nimport 'core-js/modules/es.object.entries.js';\nimport 'core-js/modules/es.array.every.js';\nimport 'core-js/modules/es.array.splice.js';\nimport 'core-js/modules/es.function.name.js';\nimport 'core-js/modules/es.array.sort.js';\nimport 'core-js/modules/web.url-search-params.js';\nimport fetch from 'cross-fetch';\nimport 'url-search-params-polyfill';\nimport 'core-js/modules/es.reflect.construct.js';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport _wrapNativeSuper from '@babel/runtime/helpers/wrapNativeSuper';\nvar _excluded$2 = [\"query\"];\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar DEFAULT_GRANULARITY = 'day';\nvar GRANULARITIES = [{\n  name: undefined,\n  title: 'w/o grouping'\n}, {\n  name: 'second',\n  title: 'Second'\n}, {\n  name: 'minute',\n  title: 'Minute'\n}, {\n  name: 'hour',\n  title: 'Hour'\n}, {\n  name: 'day',\n  title: 'Day'\n}, {\n  name: 'week',\n  title: 'Week'\n}, {\n  name: 'month',\n  title: 'Month'\n}, {\n  name: 'quarter',\n  title: 'Quarter'\n}, {\n  name: 'year',\n  title: 'Year'\n}];\n\nfunction removeEmptyQueryFields(_query) {\n  var query = _query || {};\n  return fromPairs(toPairs(query).map(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    if (['measures', 'dimensions', 'segments', 'timeDimensions', 'filters'].includes(key)) {\n      if (Array.isArray(value) && value.length === 0) {\n        return null;\n      }\n    }\n\n    if (key === 'order' && value) {\n      if (Array.isArray(value) && !value.length) {\n        return null;\n      } else if (!Object.keys(value).length) {\n        return null;\n      }\n    }\n\n    return [key, value];\n  }).filter(Boolean));\n}\n\nfunction validateQuery(_query) {\n  var query = _query || {};\n  return removeEmptyQueryFields(_objectSpread$3(_objectSpread$3({}, query), {}, {\n    filters: (query.filters || []).filter(function (f) {\n      return f.operator;\n    }),\n    timeDimensions: (query.timeDimensions || []).filter(function (td) {\n      return !(!td.dateRange && !td.granularity);\n    })\n  }));\n}\n\nfunction areQueriesEqual() {\n  var query1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var query2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return equals(Object.entries(query1 && query1.order || {}), Object.entries(query2 && query2.order || {})) && equals(query1, query2);\n}\n\nfunction defaultOrder(query) {\n  var granularity = (query.timeDimensions || []).find(function (d) {\n    return d.granularity;\n  });\n\n  if (granularity) {\n    return _defineProperty({}, granularity.dimension, 'asc');\n  } else if ((query.measures || []).length > 0 && (query.dimensions || []).length > 0) {\n    return _defineProperty({}, query.measures[0], 'desc');\n  } else if ((query.dimensions || []).length > 0) {\n    return _defineProperty({}, query.dimensions[0], 'asc');\n  }\n\n  return {};\n}\n\nfunction defaultHeuristics(newState) {\n  var oldQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var options = arguments.length > 2 ? arguments[2] : undefined;\n\n  var _clone = clone(newState),\n      query = _clone.query,\n      props = _objectWithoutProperties(_clone, _excluded$2);\n\n  var meta = options.meta,\n      sessionGranularity = options.sessionGranularity;\n  var granularity = sessionGranularity || DEFAULT_GRANULARITY;\n\n  var state = _objectSpread$3({\n    query: query\n  }, props);\n\n  var newQuery = null;\n\n  if (!areQueriesEqual(query, oldQuery)) {\n    newQuery = query;\n  }\n\n  if (Array.isArray(newQuery) || Array.isArray(oldQuery)) {\n    return newState;\n  }\n\n  if (newQuery) {\n    if ((oldQuery.timeDimensions || []).length === 1 && (newQuery.timeDimensions || []).length === 1 && newQuery.timeDimensions[0].granularity && oldQuery.timeDimensions[0].granularity !== newQuery.timeDimensions[0].granularity) {\n      state = _objectSpread$3(_objectSpread$3({}, state), {}, {\n        sessionGranularity: newQuery.timeDimensions[0].granularity\n      });\n    }\n\n    if ((oldQuery.measures || []).length === 0 && (newQuery.measures || []).length > 0 || (oldQuery.measures || []).length === 1 && (newQuery.measures || []).length === 1 && oldQuery.measures[0] !== newQuery.measures[0]) {\n      var _ref6 = newQuery.timeDimensions || [],\n          _ref7 = _slicedToArray(_ref6, 1),\n          td = _ref7[0];\n\n      var defaultTimeDimension = meta.defaultTimeDimensionNameFor(newQuery.measures[0]);\n      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {\n        timeDimensions: defaultTimeDimension ? [{\n          dimension: defaultTimeDimension,\n          granularity: td && td.granularity || granularity,\n          dateRange: td && td.dateRange\n        }] : []\n      });\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: defaultTimeDimension ? 'line' : 'number'\n      });\n    }\n\n    if ((oldQuery.dimensions || []).length === 0 && (newQuery.dimensions || []).length > 0) {\n      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {\n        timeDimensions: (newQuery.timeDimensions || []).map(function (td) {\n          return _objectSpread$3(_objectSpread$3({}, td), {}, {\n            granularity: undefined\n          });\n        })\n      });\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: 'table'\n      });\n    }\n\n    if ((oldQuery.dimensions || []).length > 0 && (newQuery.dimensions || []).length === 0) {\n      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {\n        timeDimensions: (newQuery.timeDimensions || []).map(function (td) {\n          return _objectSpread$3(_objectSpread$3({}, td), {}, {\n            granularity: td.granularity || granularity\n          });\n        })\n      });\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        chartType: (newQuery.timeDimensions || []).length ? 'line' : 'number'\n      });\n    }\n\n    if (((oldQuery.dimensions || []).length > 0 || (oldQuery.measures || []).length > 0) && (newQuery.dimensions || []).length === 0 && (newQuery.measures || []).length === 0) {\n      newQuery = _objectSpread$3(_objectSpread$3({}, newQuery), {}, {\n        timeDimensions: [],\n        filters: []\n      });\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: newQuery,\n        sessionGranularity: null\n      });\n    }\n\n    return state;\n  }\n\n  if (state.chartType) {\n    var newChartType = state.chartType;\n\n    if ((newChartType === 'line' || newChartType === 'area') && (oldQuery.timeDimensions || []).length === 1 && !oldQuery.timeDimensions[0].granularity) {\n      var _oldQuery$timeDimensi = _slicedToArray(oldQuery.timeDimensions, 1),\n          _td = _oldQuery$timeDimensi[0];\n\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        query: _objectSpread$3(_objectSpread$3({}, oldQuery), {}, {\n          timeDimensions: [_objectSpread$3(_objectSpread$3({}, _td), {}, {\n            granularity: granularity\n          })]\n        })\n      });\n    }\n\n    if ((newChartType === 'pie' || newChartType === 'table' || newChartType === 'number') && (oldQuery.timeDimensions || []).length === 1 && oldQuery.timeDimensions[0].granularity) {\n      var _oldQuery$timeDimensi2 = _slicedToArray(oldQuery.timeDimensions, 1),\n          _td2 = _oldQuery$timeDimensi2[0];\n\n      return _objectSpread$3(_objectSpread$3({}, state), {}, {\n        pivotConfig: null,\n        shouldApplyHeuristicOrder: true,\n        query: _objectSpread$3(_objectSpread$3({}, oldQuery), {}, {\n          timeDimensions: [_objectSpread$3(_objectSpread$3({}, _td2), {}, {\n            granularity: undefined\n          })]\n        })\n      });\n    }\n  }\n\n  return state;\n}\n\nfunction isQueryPresent(query) {\n  if (!query) {\n    return false;\n  }\n\n  return (Array.isArray(query) ? query : [query]).every(function (q) {\n    return q.measures && q.measures.length || q.dimensions && q.dimensions.length || q.timeDimensions && q.timeDimensions.length;\n  });\n}\n\nfunction movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis) {\n  var nextPivotConfig = _objectSpread$3(_objectSpread$3({}, pivotConfig), {}, {\n    x: _toConsumableArray(pivotConfig.x),\n    y: _toConsumableArray(pivotConfig.y)\n  });\n\n  var id = pivotConfig[sourceAxis][sourceIndex];\n  var lastIndex = nextPivotConfig[destinationAxis].length - 1;\n\n  if (id === 'measures') {\n    destinationIndex = lastIndex + 1;\n  } else if (destinationIndex >= lastIndex && nextPivotConfig[destinationAxis][lastIndex] === 'measures') {\n    destinationIndex = lastIndex - 1;\n  }\n\n  nextPivotConfig[sourceAxis].splice(sourceIndex, 1);\n  nextPivotConfig[destinationAxis].splice(destinationIndex, 0, id);\n  return nextPivotConfig;\n}\n\nfunction moveItemInArray(list, sourceIndex, destinationIndex) {\n  var result = _toConsumableArray(list);\n\n  var _result$splice = result.splice(sourceIndex, 1),\n      _result$splice2 = _slicedToArray(_result$splice, 1),\n      removed = _result$splice2[0];\n\n  result.splice(destinationIndex, 0, removed);\n  return result;\n}\n\nfunction flattenFilters() {\n  var filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n  return filters.reduce(function (memo, filter) {\n    if (filter.or || filter.and) {\n      return [].concat(_toConsumableArray(memo), _toConsumableArray(flattenFilters(filter.or || filter.and)));\n    }\n\n    return [].concat(_toConsumableArray(memo), [filter]);\n  }, []);\n}\n\nfunction getQueryMembers() {\n  var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var keys = ['measures', 'dimensions', 'segments'];\n  var members = new Set();\n  keys.forEach(function (key) {\n    return (query[key] || []).forEach(function (member) {\n      return members.add(member);\n    });\n  });\n  (query.timeDimensions || []).forEach(function (td) {\n    return members.add(td.dimension);\n  });\n  flattenFilters(query.filters).forEach(function (filter) {\n    return members.add(filter.dimension || filter.member);\n  });\n  return _toConsumableArray(members);\n}\n\nfunction getOrderMembersFromOrder(orderMembers, order) {\n  var ids = new Set();\n  var indexedOrderMembers = indexBy(prop('id'), orderMembers);\n  var entries = Array.isArray(order) ? order : Object.entries(order || {});\n  var nextOrderMembers = [];\n  entries.forEach(function (_ref8) {\n    var _ref9 = _slicedToArray(_ref8, 2),\n        memberId = _ref9[0],\n        currentOrder = _ref9[1];\n\n    if (currentOrder !== 'none' && indexedOrderMembers[memberId]) {\n      ids.add(memberId);\n      nextOrderMembers.push(_objectSpread$3(_objectSpread$3({}, indexedOrderMembers[memberId]), {}, {\n        order: currentOrder\n      }));\n    }\n  });\n  orderMembers.forEach(function (member) {\n    if (!ids.has(member.id)) {\n      nextOrderMembers.push(_objectSpread$3(_objectSpread$3({}, member), {}, {\n        order: member.order || 'none'\n      }));\n    }\n  });\n  return nextOrderMembers;\n}\n\nfunction aliasSeries(values, index, pivotConfig, duplicateMeasures) {\n  var nonNullValues = values.filter(function (value) {\n    return value != null;\n  });\n\n  if (pivotConfig && pivotConfig.aliasSeries && pivotConfig.aliasSeries[index]) {\n    return [pivotConfig.aliasSeries[index]].concat(_toConsumableArray(nonNullValues));\n  } else if (duplicateMeasures.has(nonNullValues[0])) {\n    return [index].concat(_toConsumableArray(nonNullValues));\n  }\n\n  return nonNullValues;\n}\n\nvar _excluded$1 = [\"x\"],\n    _excluded2 = [\"key\"],\n    _excluded3 = [\"title\", \"shortTitle\"];\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\ndayjs.extend(quarterOfYear); // When granularity is week, weekStart Value must be 1. However, since the client can change it globally (https://day.js.org/docs/en/i18n/changing-locale)\n// So the function below has been added.\n\nvar internalDayjs = function internalDayjs() {\n  return dayjs.apply(void 0, arguments).locale(_objectSpread$2(_objectSpread$2({}, en), {}, {\n    weekStart: 1\n  }));\n};\n\nvar TIME_SERIES = {\n  day: function day(range) {\n    return range.by('d').map(function (d) {\n      return d.format('YYYY-MM-DDT00:00:00.000');\n    });\n  },\n  month: function month(range) {\n    return range.snapTo('month').by('M').map(function (d) {\n      return d.format('YYYY-MM-01T00:00:00.000');\n    });\n  },\n  year: function year(range) {\n    return range.snapTo('year').by('y').map(function (d) {\n      return d.format('YYYY-01-01T00:00:00.000');\n    });\n  },\n  hour: function hour(range) {\n    return range.by('h').map(function (d) {\n      return d.format('YYYY-MM-DDTHH:00:00.000');\n    });\n  },\n  minute: function minute(range) {\n    return range.by('m').map(function (d) {\n      return d.format('YYYY-MM-DDTHH:mm:00.000');\n    });\n  },\n  second: function second(range) {\n    return range.by('s').map(function (d) {\n      return d.format('YYYY-MM-DDTHH:mm:ss.000');\n    });\n  },\n  week: function week(range) {\n    return range.snapTo('week').by('w').map(function (d) {\n      return d.startOf('week').format('YYYY-MM-DDT00:00:00.000');\n    });\n  },\n  quarter: function quarter(range) {\n    return range.snapTo('quarter').by('quarter').map(function (d) {\n      return d.startOf('quarter').format('YYYY-MM-DDT00:00:00.000');\n    });\n  }\n};\nvar DateRegex = /^\\d\\d\\d\\d-\\d\\d-\\d\\d$/;\nvar LocalDateRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{3}Z?$/;\n\nvar groupByToPairs = function groupByToPairs(keyFn) {\n  var acc = new Map();\n  return function (data) {\n    data.forEach(function (row) {\n      var key = keyFn(row);\n\n      if (!acc.has(key)) {\n        acc.set(key, []);\n      }\n\n      acc.get(key).push(row);\n    });\n    return Array.from(acc.entries());\n  };\n};\n\nvar unnest = function unnest(arr) {\n  var res = [];\n  arr.forEach(function (subArr) {\n    subArr.forEach(function (element) {\n      return res.push(element);\n    });\n  });\n  return res;\n};\n\nvar dayRange = function dayRange(from, to) {\n  return {\n    by: function by(value) {\n      var results = [];\n      var start = internalDayjs(from);\n      var end = internalDayjs(to);\n\n      while (start.isBefore(end) || start.isSame(end)) {\n        results.push(start);\n        start = start.add(1, value);\n      }\n\n      return results;\n    },\n    snapTo: function snapTo(value) {\n      return dayRange(internalDayjs(from).startOf(value), internalDayjs(to).endOf(value));\n    },\n    start: internalDayjs(from),\n    end: internalDayjs(to)\n  };\n};\n\nvar QUERY_TYPE = {\n  REGULAR_QUERY: 'regularQuery',\n  COMPARE_DATE_RANGE_QUERY: 'compareDateRangeQuery',\n  BLENDING_QUERY: 'blendingQuery'\n};\n\nvar ResultSet = /*#__PURE__*/function () {\n  function ResultSet(loadResponse) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, ResultSet);\n\n    this.loadResponse = loadResponse;\n\n    if (this.loadResponse.queryType != null) {\n      this.queryType = loadResponse.queryType;\n      this.loadResponses = loadResponse.results;\n    } else {\n      this.queryType = QUERY_TYPE.REGULAR_QUERY;\n      this.loadResponse.pivotQuery = _objectSpread$2(_objectSpread$2({}, loadResponse.query), {}, {\n        queryType: this.queryType\n      });\n      this.loadResponses = [loadResponse];\n    }\n\n    if (!Object.values(QUERY_TYPE).includes(this.queryType)) {\n      throw new Error('Unknown query type');\n    }\n\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.options = options;\n    this.backwardCompatibleData = [];\n  }\n\n  _createClass(ResultSet, [{\n    key: \"drillDown\",\n    value: function drillDown(drillDownLocator, pivotConfig) {\n      if (this.queryType === QUERY_TYPE.COMPARE_DATE_RANGE_QUERY) {\n        throw new Error('compareDateRange drillDown query is not currently supported');\n      }\n\n      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n        throw new Error('Data blending drillDown query is not currently supported');\n      }\n\n      var _drillDownLocator$xVa = drillDownLocator.xValues,\n          xValues = _drillDownLocator$xVa === void 0 ? [] : _drillDownLocator$xVa,\n          _drillDownLocator$yVa = drillDownLocator.yValues,\n          yValues = _drillDownLocator$yVa === void 0 ? [] : _drillDownLocator$yVa;\n      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig);\n      var values = [];\n      normalizedPivotConfig.x.forEach(function (member, currentIndex) {\n        return values.push([member, xValues[currentIndex]]);\n      });\n      normalizedPivotConfig.y.forEach(function (member, currentIndex) {\n        return values.push([member, yValues[currentIndex]]);\n      });\n\n      var _this$query = this.query(),\n          _this$query$filters = _this$query.filters,\n          parentFilters = _this$query$filters === void 0 ? [] : _this$query$filters,\n          _this$query$segments = _this$query.segments,\n          segments = _this$query$segments === void 0 ? [] : _this$query$segments;\n\n      var measures = this.loadResponses[0].annotation.measures;\n\n      var _ref = values.find(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            member = _ref4[0];\n\n        return member === 'measures';\n      }) || [],\n          _ref2 = _slicedToArray(_ref, 2),\n          measureName = _ref2[1];\n\n      if (measureName === undefined) {\n        var _Object$keys = Object.keys(measures);\n\n        var _Object$keys2 = _slicedToArray(_Object$keys, 1);\n\n        measureName = _Object$keys2[0];\n      }\n\n      if (!(measures[measureName] && measures[measureName].drillMembers || []).length) {\n        return null;\n      }\n\n      var filters = [{\n        member: measureName,\n        operator: 'measureFilter'\n      }].concat(_toConsumableArray(parentFilters));\n      var timeDimensions = [];\n      values.filter(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n            member = _ref6[0];\n\n        return member !== 'measures';\n      }).forEach(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            member = _ref8[0],\n            value = _ref8[1];\n\n        var _member$split = member.split('.'),\n            _member$split2 = _slicedToArray(_member$split, 3),\n            cubeName = _member$split2[0],\n            dimension = _member$split2[1],\n            granularity = _member$split2[2];\n\n        if (granularity !== undefined) {\n          var range = dayRange(value, value).snapTo(granularity);\n          timeDimensions.push({\n            dimension: [cubeName, dimension].join('.'),\n            dateRange: [range.start, range.end].map(function (dt) {\n              return dt.format('YYYY-MM-DDTHH:mm:ss.SSS');\n            })\n          });\n        } else if (value == null) {\n          filters.push({\n            member: member,\n            operator: 'notSet'\n          });\n        } else {\n          filters.push({\n            member: member,\n            operator: 'equals',\n            values: [value.toString()]\n          });\n        }\n      });\n      var query = this.loadResponses[0].query;\n\n      if (timeDimensions.length === 0 && query.timeDimensions.length > 0 && query.timeDimensions[0].granularity == null) {\n        timeDimensions.push(query.timeDimensions[0]);\n      }\n\n      return _objectSpread$2(_objectSpread$2(_objectSpread$2({}, measures[measureName].drillMembersGrouped), {}, {\n        filters: filters\n      }, segments.length > 0 ? {\n        segments: segments\n      } : {}), {}, {\n        timeDimensions: timeDimensions,\n        segments: segments,\n        timezone: query.timezone\n      });\n    }\n  }, {\n    key: \"series\",\n    value: function series(pivotConfig) {\n      var _this = this;\n\n      return this.seriesNames(pivotConfig).map(function (_ref9) {\n        var title = _ref9.title,\n            key = _ref9.key;\n        return {\n          title: title,\n          key: key,\n          series: _this.chartPivot(pivotConfig).map(function (_ref10) {\n            var x = _ref10.x,\n                obj = _objectWithoutProperties(_ref10, _excluded$1);\n\n            return {\n              value: obj[key],\n              x: x\n            };\n          })\n        };\n      });\n    }\n  }, {\n    key: \"axisValues\",\n    value: function axisValues(axis) {\n      var resultIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var query = this.loadResponses[resultIndex].query;\n      return function (row) {\n        var value = function value(measure) {\n          return axis.filter(function (d) {\n            return d !== 'measures';\n          }).map(function (d) {\n            return row[d] != null ? row[d] : null;\n          }).concat(measure ? [measure] : []);\n        };\n\n        if (axis.find(function (d) {\n          return d === 'measures';\n        }) && (query.measures || []).length) {\n          return query.measures.map(value);\n        }\n\n        return [value()];\n      };\n    }\n  }, {\n    key: \"axisValuesString\",\n    value: function axisValuesString(axisValues, delimiter) {\n      var formatValue = function formatValue(v) {\n        if (v == null) {\n          return '∅';\n        } else if (v === '') {\n          return '[Empty string]';\n        } else {\n          return v;\n        }\n      };\n\n      return axisValues.map(formatValue).join(delimiter || ', ');\n    }\n  }, {\n    key: \"normalizePivotConfig\",\n    value: function normalizePivotConfig(pivotConfig) {\n      return ResultSet.getNormalizedPivotConfig(this.loadResponse.pivotQuery, pivotConfig);\n    }\n  }, {\n    key: \"timeSeries\",\n    value: function timeSeries(timeDimension, resultIndex) {\n      if (!timeDimension.granularity) {\n        return null;\n      }\n\n      var dateRange = timeDimension.dateRange;\n\n      if (!dateRange) {\n        var member = ResultSet.timeDimensionMember(timeDimension);\n        var dates = pipe(map(function (row) {\n          return row[member] && internalDayjs(row[member]);\n        }), filter(Boolean))(this.timeDimensionBackwardCompatibleData(resultIndex));\n        dateRange = dates.length && [reduce(minBy(function (d) {\n          return d.toDate();\n        }), dates[0], dates), reduce(maxBy(function (d) {\n          return d.toDate();\n        }), dates[0], dates)] || null;\n      }\n\n      if (!dateRange) {\n        return null;\n      }\n\n      var padToDay = timeDimension.dateRange ? timeDimension.dateRange.find(function (d) {\n        return d.match(DateRegex);\n      }) : !['hour', 'minute', 'second'].includes(timeDimension.granularity);\n\n      var _dateRange = dateRange,\n          _dateRange2 = _slicedToArray(_dateRange, 2),\n          start = _dateRange2[0],\n          end = _dateRange2[1];\n\n      var range = dayRange(start, end);\n\n      if (!TIME_SERIES[timeDimension.granularity]) {\n        throw new Error(\"Unsupported time granularity: \".concat(timeDimension.granularity));\n      }\n\n      return TIME_SERIES[timeDimension.granularity](padToDay ? range.snapTo('d') : range);\n    }\n  }, {\n    key: \"pivot\",\n    value: function pivot(pivotConfig) {\n      var _this2 = this;\n\n      pivotConfig = this.normalizePivotConfig(pivotConfig);\n      var query = this.loadResponse.pivotQuery;\n\n      var pivotImpl = function pivotImpl() {\n        var resultIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var groupByXAxis = groupByToPairs(function (_ref11) {\n          var xValues = _ref11.xValues;\n          return _this2.axisValuesString(xValues);\n        });\n\n        var measureValue = function measureValue(row, measure) {\n          return row[measure] || 0;\n        };\n\n        if (pivotConfig.fillMissingDates && pivotConfig.x.length === 1 && equals(pivotConfig.x, (query.timeDimensions || []).filter(function (td) {\n          return Boolean(td.granularity);\n        }).map(function (td) {\n          return ResultSet.timeDimensionMember(td);\n        }))) {\n          var series = _this2.loadResponses.map(function (loadResponse) {\n            return _this2.timeSeries(loadResponse.query.timeDimensions[0], resultIndex);\n          });\n\n          if (series[0]) {\n            groupByXAxis = function groupByXAxis(rows) {\n              var byXValues = groupBy(function (_ref12) {\n                var xValues = _ref12.xValues;\n                return xValues[0];\n              }, rows);\n              return series[resultIndex].map(function (d) {\n                return [d, byXValues[d] || [{\n                  xValues: [d],\n                  row: {}\n                }]];\n              });\n            };\n          }\n        }\n\n        var xGrouped = pipe(map(function (row) {\n          return _this2.axisValues(pivotConfig.x, resultIndex)(row).map(function (xValues) {\n            return {\n              xValues: xValues,\n              row: row\n            };\n          });\n        }), unnest, groupByXAxis)(_this2.timeDimensionBackwardCompatibleData(resultIndex));\n        var yValuesMap = {};\n        xGrouped.forEach(function (_ref13) {\n          var _ref14 = _slicedToArray(_ref13, 2),\n              rows = _ref14[1];\n\n          rows.forEach(function (_ref15) {\n            var row = _ref15.row;\n\n            _this2.axisValues(pivotConfig.y, resultIndex)(row).forEach(function (values) {\n              if (Object.keys(row).length > 0) {\n                yValuesMap[values.join()] = values;\n              }\n            });\n          });\n        });\n        var allYValues = Object.values(yValuesMap);\n        var measureOnX = Boolean(pivotConfig.x.find(function (d) {\n          return d === 'measures';\n        }));\n        return xGrouped.map(function (_ref16) {\n          var _ref17 = _slicedToArray(_ref16, 2),\n              rows = _ref17[1];\n\n          var xValues = rows[0].xValues;\n          var yGrouped = {};\n          rows.forEach(function (_ref18) {\n            var row = _ref18.row;\n\n            var arr = _this2.axisValues(pivotConfig.y, resultIndex)(row).map(function (yValues) {\n              return {\n                yValues: yValues,\n                row: row\n              };\n            });\n\n            arr.forEach(function (res) {\n              yGrouped[_this2.axisValuesString(res.yValues)] = res;\n            });\n          });\n          return {\n            xValues: xValues,\n            yValuesArray: unnest(allYValues.map(function (yValues) {\n              var measure = measureOnX ? ResultSet.measureFromAxis(xValues) : ResultSet.measureFromAxis(yValues);\n              return [[yValues, measureValue((yGrouped[_this2.axisValuesString(yValues)] || {\n                row: {}\n              }).row, measure)]];\n            }))\n          };\n        });\n      };\n\n      var pivots = this.loadResponses.length > 1 ? this.loadResponses.map(function (_, index) {\n        return pivotImpl(index);\n      }) : [];\n      return pivots.length ? this.mergePivots(pivots, pivotConfig.joinDateRange) : pivotImpl();\n    }\n  }, {\n    key: \"mergePivots\",\n    value: function mergePivots(pivots, joinDateRange) {\n      var minLengthPivot = pivots.reduce(function (memo, current) {\n        return memo != null && current.length >= memo.length ? memo : current;\n      }, null);\n      return minLengthPivot.map(function (_, index) {\n        var xValues = joinDateRange ? [pivots.map(function (pivot) {\n          return pivot[index] && pivot[index].xValues || [];\n        }).join(', ')] : minLengthPivot[index].xValues;\n        return {\n          xValues: xValues,\n          yValuesArray: unnest(pivots.map(function (pivot) {\n            return pivot[index].yValuesArray;\n          }))\n        };\n      });\n    }\n  }, {\n    key: \"pivotedRows\",\n    value: function pivotedRows(pivotConfig) {\n      // TODO\n      return this.chartPivot(pivotConfig);\n    }\n  }, {\n    key: \"chartPivot\",\n    value: function chartPivot(pivotConfig) {\n      var _this3 = this;\n\n      var validate = function validate(value) {\n        if (_this3.parseDateMeasures && LocalDateRegex.test(value)) {\n          return new Date(value);\n        } else if (!Number.isNaN(Number.parseFloat(value))) {\n          return Number.parseFloat(value);\n        }\n\n        return value;\n      };\n\n      var duplicateMeasures = new Set();\n\n      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n        var allMeasures = flatten(this.loadResponses.map(function (_ref19) {\n          var query = _ref19.query;\n          return query.measures;\n        }));\n        allMeasures.filter(function (e, i, a) {\n          return a.indexOf(e) !== i;\n        }).forEach(function (m) {\n          return duplicateMeasures.add(m);\n        });\n      }\n\n      return this.pivot(pivotConfig).map(function (_ref20) {\n        var xValues = _ref20.xValues,\n            yValuesArray = _ref20.yValuesArray;\n        var yValuesMap = {};\n        yValuesArray.forEach(function (_ref21, i) {\n          var _ref22 = _slicedToArray(_ref21, 2),\n              yValues = _ref22[0],\n              m = _ref22[1];\n\n          yValuesMap[_this3.axisValuesString(aliasSeries(yValues, i, pivotConfig, duplicateMeasures), ',')] = m && validate(m);\n        });\n        return _objectSpread$2({\n          x: _this3.axisValuesString(xValues, ','),\n          xValues: xValues\n        }, yValuesMap);\n      });\n    }\n  }, {\n    key: \"tablePivot\",\n    value: function tablePivot(pivotConfig) {\n      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n      var isMeasuresPresent = normalizedPivotConfig.x.concat(normalizedPivotConfig.y).includes('measures');\n      return this.pivot(normalizedPivotConfig).map(function (_ref23) {\n        var xValues = _ref23.xValues,\n            yValuesArray = _ref23.yValuesArray;\n        return fromPairs(normalizedPivotConfig.x.map(function (key, index) {\n          return [key, xValues[index]];\n        }).concat(isMeasuresPresent ? yValuesArray.map(function (_ref24) {\n          var _ref25 = _slicedToArray(_ref24, 2),\n              yValues = _ref25[0],\n              measure = _ref25[1];\n\n          return [yValues.length ? yValues.join() : 'value', measure];\n        }) : []));\n      });\n    }\n  }, {\n    key: \"tableColumns\",\n    value: function tableColumns(pivotConfig) {\n      var normalizedPivotConfig = this.normalizePivotConfig(pivotConfig || {});\n      var annotations = pipe(pluck('annotation'), reduce(mergeDeepLeft(), {}))(this.loadResponses);\n      var flatMeta = Object.values(annotations).reduce(function (a, b) {\n        return _objectSpread$2(_objectSpread$2({}, a), b);\n      }, {});\n      var schema = {};\n\n      var extractFields = function extractFields(key) {\n        var _ref26 = flatMeta[key] || {},\n            title = _ref26.title,\n            shortTitle = _ref26.shortTitle,\n            type = _ref26.type,\n            format = _ref26.format,\n            meta = _ref26.meta;\n\n        return {\n          key: key,\n          title: title,\n          shortTitle: shortTitle,\n          type: type,\n          format: format,\n          meta: meta\n        };\n      };\n\n      var pivot = this.pivot(normalizedPivotConfig);\n      (pivot[0] && pivot[0].yValuesArray || []).forEach(function (_ref27) {\n        var _ref28 = _slicedToArray(_ref27, 1),\n            yValues = _ref28[0];\n\n        if (yValues.length > 0) {\n          var currentItem = schema;\n          yValues.forEach(function (value, index) {\n            currentItem[\"_\".concat(value)] = {\n              key: value,\n              memberId: normalizedPivotConfig.y[index] === 'measures' ? value : normalizedPivotConfig.y[index],\n              children: currentItem[\"_\".concat(value)] && currentItem[\"_\".concat(value)].children || {}\n            };\n            currentItem = currentItem[\"_\".concat(value)].children;\n          });\n        }\n      });\n\n      var toColumns = function toColumns() {\n        var item = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n        if (Object.keys(item).length === 0) {\n          return [];\n        }\n\n        return Object.values(item).map(function (_ref29) {\n          var key = _ref29.key,\n              currentItem = _objectWithoutProperties(_ref29, _excluded2);\n\n          var children = toColumns(currentItem.children, [].concat(_toConsumableArray(path), [key]));\n\n          var _extractFields = extractFields(currentItem.memberId),\n              title = _extractFields.title,\n              shortTitle = _extractFields.shortTitle,\n              fields = _objectWithoutProperties(_extractFields, _excluded3);\n\n          var dimensionValue = key !== currentItem.memberId || title == null ? key : '';\n\n          if (!children.length) {\n            return _objectSpread$2(_objectSpread$2({}, fields), {}, {\n              key: key,\n              dataIndex: [].concat(_toConsumableArray(path), [key]).join(),\n              title: [title, dimensionValue].join(' ').trim(),\n              shortTitle: dimensionValue || shortTitle\n            });\n          }\n\n          return _objectSpread$2(_objectSpread$2({}, fields), {}, {\n            key: key,\n            title: [title, dimensionValue].join(' ').trim(),\n            shortTitle: dimensionValue || shortTitle,\n            children: children\n          });\n        });\n      };\n\n      var otherColumns = [];\n\n      if (!pivot.length && normalizedPivotConfig.y.includes('measures')) {\n        otherColumns = (this.loadResponses[0].query.measures || []).map(function (key) {\n          return _objectSpread$2(_objectSpread$2({}, extractFields(key)), {}, {\n            dataIndex: key\n          });\n        });\n      } // Syntatic column to display the measure value\n\n\n      if (!normalizedPivotConfig.y.length && normalizedPivotConfig.x.includes('measures')) {\n        otherColumns.push({\n          key: 'value',\n          dataIndex: 'value',\n          title: 'Value',\n          shortTitle: 'Value',\n          type: 'string'\n        });\n      }\n\n      return normalizedPivotConfig.x.map(function (key) {\n        if (key === 'measures') {\n          return {\n            key: 'measures',\n            dataIndex: 'measures',\n            title: 'Measures',\n            shortTitle: 'Measures',\n            type: 'string'\n          };\n        }\n\n        return _objectSpread$2(_objectSpread$2({}, extractFields(key)), {}, {\n          dataIndex: key\n        });\n      }).concat(toColumns(schema)).concat(otherColumns);\n    }\n  }, {\n    key: \"totalRow\",\n    value: function totalRow(pivotConfig) {\n      return this.chartPivot(pivotConfig)[0];\n    }\n  }, {\n    key: \"categories\",\n    value: function categories(pivotConfig) {\n      // TODO\n      return this.chartPivot(pivotConfig);\n    }\n  }, {\n    key: \"seriesNames\",\n    value: function seriesNames(pivotConfig) {\n      var _this4 = this;\n\n      pivotConfig = this.normalizePivotConfig(pivotConfig);\n      var measures = pipe(pluck('annotation'), pluck('measures'), mergeAll)(this.loadResponses);\n      var seriesNames = unnest(this.loadResponses.map(function (_, index) {\n        return pipe(map(_this4.axisValues(pivotConfig.y, index)), unnest, uniq)(_this4.timeDimensionBackwardCompatibleData(index));\n      }));\n      var duplicateMeasures = new Set();\n\n      if (this.queryType === QUERY_TYPE.BLENDING_QUERY) {\n        var allMeasures = flatten(this.loadResponses.map(function (_ref30) {\n          var query = _ref30.query;\n          return query.measures;\n        }));\n        allMeasures.filter(function (e, i, a) {\n          return a.indexOf(e) !== i;\n        }).forEach(function (m) {\n          return duplicateMeasures.add(m);\n        });\n      }\n\n      return seriesNames.map(function (axisValues, i) {\n        var aliasedAxis = aliasSeries(axisValues, i, pivotConfig, duplicateMeasures);\n        return {\n          title: _this4.axisValuesString(pivotConfig.y.find(function (d) {\n            return d === 'measures';\n          }) ? dropLast(1, aliasedAxis).concat(measures[ResultSet.measureFromAxis(axisValues)].title) : aliasedAxis, ', '),\n          key: _this4.axisValuesString(aliasedAxis, ','),\n          yValues: axisValues\n        };\n      });\n    }\n  }, {\n    key: \"query\",\n    value: function query() {\n      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n        throw new Error(\"Method is not supported for a '\".concat(this.queryType, \"' query type. Please use decompose\"));\n      }\n\n      return this.loadResponses[0].query;\n    }\n  }, {\n    key: \"pivotQuery\",\n    value: function pivotQuery() {\n      return this.loadResponse.pivotQuery || null;\n    }\n  }, {\n    key: \"rawData\",\n    value: function rawData() {\n      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n        throw new Error(\"Method is not supported for a '\".concat(this.queryType, \"' query type. Please use decompose\"));\n      }\n\n      return this.loadResponses[0].data;\n    }\n  }, {\n    key: \"annotation\",\n    value: function annotation() {\n      if (this.queryType !== QUERY_TYPE.REGULAR_QUERY) {\n        throw new Error(\"Method is not supported for a '\".concat(this.queryType, \"' query type. Please use decompose\"));\n      }\n\n      return this.loadResponses[0].annotation;\n    }\n  }, {\n    key: \"timeDimensionBackwardCompatibleData\",\n    value: function timeDimensionBackwardCompatibleData(resultIndex) {\n      if (resultIndex === undefined) {\n        throw new Error('resultIndex is required');\n      }\n\n      if (!this.backwardCompatibleData[resultIndex]) {\n        var _this$loadResponses$r = this.loadResponses[resultIndex],\n            data = _this$loadResponses$r.data,\n            query = _this$loadResponses$r.query;\n        var timeDimensions = (query.timeDimensions || []).filter(function (td) {\n          return Boolean(td.granularity);\n        });\n        this.backwardCompatibleData[resultIndex] = data.map(function (row) {\n          return _objectSpread$2(_objectSpread$2({}, row), fromPairs(Object.keys(row).filter(function (field) {\n            return timeDimensions.find(function (d) {\n              return d.dimension === field;\n            }) && !row[ResultSet.timeDimensionMember(timeDimensions.find(function (d) {\n              return d.dimension === field;\n            }))];\n          }).map(function (field) {\n            return [ResultSet.timeDimensionMember(timeDimensions.find(function (d) {\n              return d.dimension === field;\n            })), row[field]];\n          })));\n        });\n      }\n\n      return this.backwardCompatibleData[resultIndex];\n    }\n  }, {\n    key: \"decompose\",\n    value: function decompose() {\n      var _this5 = this;\n\n      return this.loadResponses.map(function (result) {\n        return new ResultSet({\n          queryType: QUERY_TYPE.REGULAR_QUERY,\n          pivotQuery: _objectSpread$2(_objectSpread$2({}, result.query), {}, {\n            queryType: QUERY_TYPE.REGULAR_QUERY\n          }),\n          results: [result]\n        }, _this5.options);\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        loadResponse: clone(this.loadResponse)\n      };\n    }\n  }], [{\n    key: \"measureFromAxis\",\n    value: function measureFromAxis(axisValues) {\n      return axisValues[axisValues.length - 1];\n    }\n  }, {\n    key: \"timeDimensionMember\",\n    value: function timeDimensionMember(td) {\n      return \"\".concat(td.dimension, \".\").concat(td.granularity);\n    }\n  }, {\n    key: \"deserialize\",\n    value: function deserialize(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return new ResultSet(data.loadResponse, options);\n    }\n  }, {\n    key: \"getNormalizedPivotConfig\",\n    value: function getNormalizedPivotConfig() {\n      var query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var pivotConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var defaultPivotConfig = {\n        x: [],\n        y: [],\n        fillMissingDates: true,\n        joinDateRange: false\n      };\n      var _query$measures = query.measures,\n          measures = _query$measures === void 0 ? [] : _query$measures,\n          _query$dimensions = query.dimensions,\n          dimensions = _query$dimensions === void 0 ? [] : _query$dimensions;\n      var timeDimensions = (query.timeDimensions || []).filter(function (td) {\n        return !!td.granularity;\n      });\n      pivotConfig = pivotConfig || (timeDimensions.length ? {\n        x: timeDimensions.map(function (td) {\n          return ResultSet.timeDimensionMember(td);\n        }),\n        y: dimensions\n      } : {\n        x: dimensions,\n        y: []\n      });\n      pivotConfig = mergeDeepLeft(pivotConfig, defaultPivotConfig);\n\n      var substituteTimeDimensionMembers = function substituteTimeDimensionMembers(axis) {\n        return axis.map(function (subDim) {\n          return timeDimensions.find(function (td) {\n            return td.dimension === subDim;\n          }) && !dimensions.find(function (d) {\n            return d === subDim;\n          }) ? ResultSet.timeDimensionMember(query.timeDimensions.find(function (td) {\n            return td.dimension === subDim;\n          })) : subDim;\n        });\n      };\n\n      pivotConfig.x = substituteTimeDimensionMembers(pivotConfig.x);\n      pivotConfig.y = substituteTimeDimensionMembers(pivotConfig.y);\n      var allIncludedDimensions = pivotConfig.x.concat(pivotConfig.y);\n      var allDimensions = timeDimensions.map(function (td) {\n        return ResultSet.timeDimensionMember(td);\n      }).concat(dimensions);\n\n      var dimensionFilter = function dimensionFilter(key) {\n        return allDimensions.includes(key) || key === 'measures';\n      };\n\n      pivotConfig.x = pivotConfig.x.concat(allDimensions.filter(function (d) {\n        return !allIncludedDimensions.includes(d) && d !== 'compareDateRange';\n      })).filter(dimensionFilter);\n      pivotConfig.y = pivotConfig.y.filter(dimensionFilter);\n\n      if (!pivotConfig.x.concat(pivotConfig.y).find(function (d) {\n        return d === 'measures';\n      })) {\n        pivotConfig.y.push('measures');\n      }\n\n      if (dimensions.includes('compareDateRange') && !pivotConfig.y.concat(pivotConfig.x).includes('compareDateRange')) {\n        pivotConfig.y.unshift('compareDateRange');\n      }\n\n      if (!measures.length) {\n        pivotConfig.x = pivotConfig.x.filter(function (d) {\n          return d !== 'measures';\n        });\n        pivotConfig.y = pivotConfig.y.filter(function (d) {\n          return d !== 'measures';\n        });\n      }\n\n      return pivotConfig;\n    }\n  }]);\n\n  return ResultSet;\n}();\n\nvar SqlQuery = /*#__PURE__*/function () {\n  function SqlQuery(sqlQuery) {\n    _classCallCheck(this, SqlQuery);\n\n    this.sqlQuery = sqlQuery;\n  }\n\n  _createClass(SqlQuery, [{\n    key: \"rawQuery\",\n    value: function rawQuery() {\n      return this.sqlQuery.sql;\n    }\n  }, {\n    key: \"sql\",\n    value: function sql() {\n      return this.rawQuery().sql[0];\n    }\n  }]);\n\n  return SqlQuery;\n}();\n\nvar memberMap = function memberMap(memberArray) {\n  return fromPairs(memberArray.map(function (m) {\n    return [m.name, m];\n  }));\n};\n\nvar operators = {\n  string: [{\n    name: 'contains',\n    title: 'contains'\n  }, {\n    name: 'notContains',\n    title: 'does not contain'\n  }, {\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'set',\n    title: 'is set'\n  }, {\n    name: 'notSet',\n    title: 'is not set'\n  }],\n  number: [{\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'set',\n    title: 'is set'\n  }, {\n    name: 'notSet',\n    title: 'is not set'\n  }, {\n    name: 'gt',\n    title: '>'\n  }, {\n    name: 'gte',\n    title: '>='\n  }, {\n    name: 'lt',\n    title: '<'\n  }, {\n    name: 'lte',\n    title: '<='\n  }],\n  time: [{\n    name: 'equals',\n    title: 'equals'\n  }, {\n    name: 'notEquals',\n    title: 'does not equal'\n  }, {\n    name: 'inDateRange',\n    title: 'in date range'\n  }, {\n    name: 'notInDateRange',\n    title: 'not in date range'\n  }, {\n    name: 'afterDate',\n    title: 'after date'\n  }, {\n    name: 'beforeDate',\n    title: 'before date'\n  }]\n};\n/**\n * Contains information about available cubes and it's members.\n */\n\nvar Meta = /*#__PURE__*/function () {\n  function Meta(metaResponse) {\n    _classCallCheck(this, Meta);\n\n    this.meta = metaResponse;\n    var cubes = this.meta.cubes;\n    this.cubes = cubes;\n    this.cubesMap = fromPairs(cubes.map(function (c) {\n      return [c.name, {\n        measures: memberMap(c.measures),\n        dimensions: memberMap(c.dimensions),\n        segments: memberMap(c.segments)\n      }];\n    }));\n  }\n\n  _createClass(Meta, [{\n    key: \"membersForQuery\",\n    value: function membersForQuery(query, memberType) {\n      return unnest$1(this.cubes.map(function (c) {\n        return c[memberType];\n      })).sort(function (a, b) {\n        return a.title > b.title ? 1 : -1;\n      });\n    }\n  }, {\n    key: \"membersGroupedByCube\",\n    value: function membersGroupedByCube() {\n      var memberKeys = ['measures', 'dimensions', 'segments', 'timeDimensions'];\n      return this.cubes.reduce(function (memo, cube) {\n        memberKeys.forEach(function (key) {\n          var members = cube[key];\n\n          if (key === 'timeDimensions') {\n            members = cube.dimensions.filter(function (m) {\n              return m.type === 'time';\n            });\n          }\n\n          memo[key] = [].concat(_toConsumableArray(memo[key]), [{\n            cubeName: cube.name,\n            cubeTitle: cube.title,\n            members: members\n          }]);\n        });\n        return memo;\n      }, {\n        measures: [],\n        dimensions: [],\n        segments: [],\n        timeDimensions: []\n      });\n    }\n  }, {\n    key: \"resolveMember\",\n    value: function resolveMember(memberName, memberType) {\n      var _this = this;\n\n      var _memberName$split = memberName.split('.'),\n          _memberName$split2 = _slicedToArray(_memberName$split, 1),\n          cube = _memberName$split2[0];\n\n      if (!this.cubesMap[cube]) {\n        return {\n          title: memberName,\n          error: \"Cube not found \".concat(cube, \" for path '\").concat(memberName, \"'\")\n        };\n      }\n\n      var memberTypes = Array.isArray(memberType) ? memberType : [memberType];\n      var member = memberTypes.map(function (type) {\n        return _this.cubesMap[cube][type] && _this.cubesMap[cube][type][memberName];\n      }).find(function (m) {\n        return m;\n      });\n\n      if (!member) {\n        return {\n          title: memberName,\n          error: \"Path not found '\".concat(memberName, \"'\")\n        };\n      }\n\n      return member;\n    }\n  }, {\n    key: \"defaultTimeDimensionNameFor\",\n    value: function defaultTimeDimensionNameFor(memberName) {\n      var _this2 = this;\n\n      var _memberName$split3 = memberName.split('.'),\n          _memberName$split4 = _slicedToArray(_memberName$split3, 1),\n          cube = _memberName$split4[0];\n\n      if (!this.cubesMap[cube]) {\n        return null;\n      }\n\n      return Object.keys(this.cubesMap[cube].dimensions || {}).find(function (d) {\n        return _this2.cubesMap[cube].dimensions[d].type === 'time';\n      });\n    }\n  }, {\n    key: \"filterOperatorsForMember\",\n    value: function filterOperatorsForMember(memberName, memberType) {\n      var member = this.resolveMember(memberName, memberType);\n      return operators[member.type] || operators.string;\n    }\n  }]);\n\n  return Meta;\n}();\n\nvar ProgressResult = /*#__PURE__*/function () {\n  function ProgressResult(progressResponse) {\n    _classCallCheck(this, ProgressResult);\n\n    this.progressResponse = progressResponse;\n  }\n\n  _createClass(ProgressResult, [{\n    key: \"stage\",\n    value: function stage() {\n      return this.progressResponse.stage;\n    }\n  }, {\n    key: \"timeElapsed\",\n    value: function timeElapsed() {\n      return this.progressResponse.timeElapsed;\n    }\n  }]);\n\n  return ProgressResult;\n}();\n\nvar _excluded = [\"baseRequestId\"];\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar HttpTransport = /*#__PURE__*/function () {\n  function HttpTransport(_ref) {\n    var authorization = _ref.authorization,\n        apiUrl = _ref.apiUrl,\n        method = _ref.method,\n        _ref$headers = _ref.headers,\n        headers = _ref$headers === void 0 ? {} : _ref$headers,\n        credentials = _ref.credentials;\n\n    _classCallCheck(this, HttpTransport);\n\n    this.authorization = authorization;\n    this.apiUrl = apiUrl;\n    this.method = method;\n    this.headers = headers;\n    this.credentials = credentials;\n  }\n\n  _createClass(HttpTransport, [{\n    key: \"request\",\n    value: function request(method, _ref2) {\n      var _this = this;\n\n      var baseRequestId = _ref2.baseRequestId,\n          params = _objectWithoutProperties(_ref2, _excluded);\n\n      var spanCounter = 1;\n      var searchParams = new URLSearchParams(params && Object.keys(params).map(function (k) {\n        return _defineProperty({}, k, _typeof(params[k]) === 'object' ? JSON.stringify(params[k]) : params[k]);\n      }).reduce(function (a, b) {\n        return _objectSpread$1(_objectSpread$1({}, a), b);\n      }, {}));\n      var url = \"\".concat(this.apiUrl, \"/\").concat(method).concat(searchParams.toString().length ? \"?\".concat(searchParams) : '');\n      var requestMethod = this.method || (url.length < 2000 ? 'GET' : 'POST');\n\n      if (requestMethod === 'POST') {\n        url = \"\".concat(this.apiUrl, \"/\").concat(method);\n        this.headers['Content-Type'] = 'application/json';\n      } // Currently, all methods make GET requests. If a method makes a request with a body payload,\n      // remember to add {'Content-Type': 'application/json'} to the header.\n\n\n      var runRequest = function runRequest() {\n        return fetch(url, {\n          method: requestMethod,\n          headers: _objectSpread$1({\n            Authorization: _this.authorization,\n            'x-request-id': baseRequestId && \"\".concat(baseRequestId, \"-span-\").concat(spanCounter++)\n          }, _this.headers),\n          credentials: _this.credentials,\n          body: requestMethod === 'POST' ? JSON.stringify(params) : null\n        });\n      };\n\n      return {\n        /* eslint no-unsafe-finally: off */\n        subscribe: function subscribe(callback) {\n          var _this2 = this;\n\n          return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n            var result;\n            return _regeneratorRuntime.wrap(function _callee$(_context) {\n              while (1) {\n                switch (_context.prev = _context.next) {\n                  case 0:\n                    result = {\n                      error: 'network Error' // add default error message\n\n                    };\n                    _context.prev = 1;\n                    _context.next = 4;\n                    return runRequest();\n\n                  case 4:\n                    result = _context.sent;\n\n                  case 5:\n                    _context.prev = 5;\n                    return _context.abrupt(\"return\", callback(result, function () {\n                      return _this2.subscribe(callback);\n                    }));\n\n                  case 8:\n                  case \"end\":\n                    return _context.stop();\n                }\n              }\n            }, _callee, null, [[1,, 5, 8]]);\n          }))();\n        }\n      };\n    }\n  }]);\n\n  return HttpTransport;\n}();\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar RequestError = /*#__PURE__*/function (_Error) {\n  _inherits(RequestError, _Error);\n\n  var _super = _createSuper(RequestError);\n\n  function RequestError(message, response, status) {\n    var _this;\n\n    _classCallCheck(this, RequestError);\n\n    _this = _super.call(this, message);\n    _this.response = response;\n    _this.status = status;\n    return _this;\n  }\n\n  return _createClass(RequestError);\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar mutexCounter = 0;\nvar MUTEX_ERROR = 'Mutex has been changed';\n/**\n * Query result dataset formats enum.\n */\n\nvar ResultType = {\n  DEFAULT: 'default',\n  COMPACT: 'compact'\n};\n\nfunction mutexPromise(promise) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee(resolve, reject) {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.prev = 0;\n              _context.t0 = resolve;\n              _context.next = 4;\n              return promise;\n\n            case 4:\n              _context.t1 = _context.sent;\n              (0, _context.t0)(_context.t1);\n              _context.next = 11;\n              break;\n\n            case 8:\n              _context.prev = 8;\n              _context.t2 = _context[\"catch\"](0);\n\n              if (_context.t2 !== MUTEX_ERROR) {\n                reject(_context.t2);\n              }\n\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[0, 8]]);\n    }));\n\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}\n\nvar CubejsApi = /*#__PURE__*/function () {\n  function CubejsApi(apiToken, options) {\n    _classCallCheck(this, CubejsApi);\n\n    if (apiToken !== null && !Array.isArray(apiToken) && _typeof(apiToken) === 'object') {\n      options = apiToken;\n      apiToken = undefined;\n    }\n\n    options = options || {};\n\n    if (!options.transport && !options.apiUrl) {\n      throw new Error('The `apiUrl` option is required');\n    }\n\n    this.apiToken = apiToken;\n    this.apiUrl = options.apiUrl;\n    this.method = options.method;\n    this.headers = options.headers || {};\n    this.credentials = options.credentials;\n    this.transport = options.transport || new HttpTransport({\n      authorization: typeof apiToken === 'function' ? undefined : apiToken,\n      apiUrl: this.apiUrl,\n      method: this.method,\n      headers: this.headers,\n      credentials: this.credentials\n    });\n    this.pollInterval = options.pollInterval || 5;\n    this.parseDateMeasures = options.parseDateMeasures;\n    this.updateAuthorizationPromise = null;\n  }\n\n  _createClass(CubejsApi, [{\n    key: \"request\",\n    value: function request(method, params) {\n      return this.transport.request(method, _objectSpread({\n        baseRequestId: v4()\n      }, params));\n    }\n  }, {\n    key: \"loadMethod\",\n    value: function loadMethod(request, toResult, options, callback) {\n      var _this = this;\n\n      var mutexValue = ++mutexCounter;\n\n      if (typeof options === 'function' && !callback) {\n        callback = options;\n        options = undefined;\n      }\n\n      options = options || {};\n      var mutexKey = options.mutexKey || 'default';\n\n      if (options.mutexObj) {\n        options.mutexObj[mutexKey] = mutexValue;\n      }\n\n      var requestPromise = this.updateTransportAuthorization().then(function () {\n        return request();\n      });\n      var skipAuthorizationUpdate = true;\n      var unsubscribed = false;\n\n      var checkMutex = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var requestInstance;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return requestPromise;\n\n                case 2:\n                  requestInstance = _context2.sent;\n\n                  if (!(options.mutexObj && options.mutexObj[mutexKey] !== mutexValue)) {\n                    _context2.next = 9;\n                    break;\n                  }\n\n                  unsubscribed = true;\n\n                  if (!requestInstance.unsubscribe) {\n                    _context2.next = 8;\n                    break;\n                  }\n\n                  _context2.next = 8;\n                  return requestInstance.unsubscribe();\n\n                case 8:\n                  throw MUTEX_ERROR;\n\n                case 9:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }));\n\n        return function checkMutex() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      var loadImpl = /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(response, next) {\n          var requestInstance, subscribeNext, continueWait, body, text, error, result;\n          return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n            while (1) {\n              switch (_context5.prev = _context5.next) {\n                case 0:\n                  _context5.next = 2;\n                  return requestPromise;\n\n                case 2:\n                  requestInstance = _context5.sent;\n\n                  subscribeNext = /*#__PURE__*/function () {\n                    var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                        while (1) {\n                          switch (_context3.prev = _context3.next) {\n                            case 0:\n                              if (!(options.subscribe && !unsubscribed)) {\n                                _context3.next = 8;\n                                break;\n                              }\n\n                              if (!requestInstance.unsubscribe) {\n                                _context3.next = 5;\n                                break;\n                              }\n\n                              return _context3.abrupt(\"return\", next());\n\n                            case 5:\n                              _context3.next = 7;\n                              return new Promise(function (resolve) {\n                                return setTimeout(function () {\n                                  return resolve();\n                                }, _this.pollInterval * 1000);\n                              });\n\n                            case 7:\n                              return _context3.abrupt(\"return\", next());\n\n                            case 8:\n                              return _context3.abrupt(\"return\", null);\n\n                            case 9:\n                            case \"end\":\n                              return _context3.stop();\n                          }\n                        }\n                      }, _callee3);\n                    }));\n\n                    return function subscribeNext() {\n                      return _ref4.apply(this, arguments);\n                    };\n                  }();\n\n                  continueWait = /*#__PURE__*/function () {\n                    var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(wait) {\n                      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n                        while (1) {\n                          switch (_context4.prev = _context4.next) {\n                            case 0:\n                              if (unsubscribed) {\n                                _context4.next = 5;\n                                break;\n                              }\n\n                              if (!wait) {\n                                _context4.next = 4;\n                                break;\n                              }\n\n                              _context4.next = 4;\n                              return new Promise(function (resolve) {\n                                return setTimeout(function () {\n                                  return resolve();\n                                }, _this.pollInterval * 1000);\n                              });\n\n                            case 4:\n                              return _context4.abrupt(\"return\", next());\n\n                            case 5:\n                              return _context4.abrupt(\"return\", null);\n\n                            case 6:\n                            case \"end\":\n                              return _context4.stop();\n                          }\n                        }\n                      }, _callee4);\n                    }));\n\n                    return function continueWait(_x5) {\n                      return _ref5.apply(this, arguments);\n                    };\n                  }();\n\n                  if (!(options.subscribe && !skipAuthorizationUpdate)) {\n                    _context5.next = 8;\n                    break;\n                  }\n\n                  _context5.next = 8;\n                  return _this.updateTransportAuthorization();\n\n                case 8:\n                  skipAuthorizationUpdate = false;\n\n                  if (!(response.status === 502)) {\n                    _context5.next = 13;\n                    break;\n                  }\n\n                  _context5.next = 12;\n                  return checkMutex();\n\n                case 12:\n                  return _context5.abrupt(\"return\", continueWait(true));\n\n                case 13:\n                  body = {};\n                  text = '';\n                  _context5.prev = 15;\n                  _context5.next = 18;\n                  return response.text();\n\n                case 18:\n                  text = _context5.sent;\n                  body = JSON.parse(text);\n                  _context5.next = 25;\n                  break;\n\n                case 22:\n                  _context5.prev = 22;\n                  _context5.t0 = _context5[\"catch\"](15);\n                  body.error = text;\n\n                case 25:\n                  if (!(body.error === 'Continue wait')) {\n                    _context5.next = 30;\n                    break;\n                  }\n\n                  _context5.next = 28;\n                  return checkMutex();\n\n                case 28:\n                  if (options.progressCallback) {\n                    options.progressCallback(new ProgressResult(body));\n                  }\n\n                  return _context5.abrupt(\"return\", continueWait());\n\n                case 30:\n                  if (!(response.status !== 200)) {\n                    _context5.next = 43;\n                    break;\n                  }\n\n                  _context5.next = 33;\n                  return checkMutex();\n\n                case 33:\n                  if (!(!options.subscribe && requestInstance.unsubscribe)) {\n                    _context5.next = 36;\n                    break;\n                  }\n\n                  _context5.next = 36;\n                  return requestInstance.unsubscribe();\n\n                case 36:\n                  error = new RequestError(body.error, body, response.status); // TODO error class\n\n                  if (!callback) {\n                    _context5.next = 41;\n                    break;\n                  }\n\n                  callback(error);\n                  _context5.next = 42;\n                  break;\n\n                case 41:\n                  throw error;\n\n                case 42:\n                  return _context5.abrupt(\"return\", subscribeNext());\n\n                case 43:\n                  _context5.next = 45;\n                  return checkMutex();\n\n                case 45:\n                  if (!(!options.subscribe && requestInstance.unsubscribe)) {\n                    _context5.next = 48;\n                    break;\n                  }\n\n                  _context5.next = 48;\n                  return requestInstance.unsubscribe();\n\n                case 48:\n                  result = toResult(body);\n\n                  if (!callback) {\n                    _context5.next = 53;\n                    break;\n                  }\n\n                  callback(null, result);\n                  _context5.next = 54;\n                  break;\n\n                case 53:\n                  return _context5.abrupt(\"return\", result);\n\n                case 54:\n                  return _context5.abrupt(\"return\", subscribeNext());\n\n                case 55:\n                case \"end\":\n                  return _context5.stop();\n              }\n            }\n          }, _callee5, null, [[15, 22]]);\n        }));\n\n        return function loadImpl(_x3, _x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }();\n\n      var promise = requestPromise.then(function (requestInstance) {\n        return mutexPromise(requestInstance.subscribe(loadImpl));\n      });\n\n      if (callback) {\n        return {\n          unsubscribe: function () {\n            var _unsubscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n              var requestInstance;\n              return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n                while (1) {\n                  switch (_context6.prev = _context6.next) {\n                    case 0:\n                      _context6.next = 2;\n                      return requestPromise;\n\n                    case 2:\n                      requestInstance = _context6.sent;\n                      unsubscribed = true;\n\n                      if (!requestInstance.unsubscribe) {\n                        _context6.next = 6;\n                        break;\n                      }\n\n                      return _context6.abrupt(\"return\", requestInstance.unsubscribe());\n\n                    case 6:\n                      return _context6.abrupt(\"return\", null);\n\n                    case 7:\n                    case \"end\":\n                      return _context6.stop();\n                  }\n                }\n              }, _callee6);\n            }));\n\n            function unsubscribe() {\n              return _unsubscribe.apply(this, arguments);\n            }\n\n            return unsubscribe;\n          }()\n        };\n      } else {\n        return promise;\n      }\n    }\n  }, {\n    key: \"updateTransportAuthorization\",\n    value: function () {\n      var _updateTransportAuthorization = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8() {\n        var _this2 = this;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                if (!this.updateAuthorizationPromise) {\n                  _context8.next = 4;\n                  break;\n                }\n\n                _context8.next = 3;\n                return this.updateAuthorizationPromise;\n\n              case 3:\n                return _context8.abrupt(\"return\");\n\n              case 4:\n                if (!(typeof this.apiToken === 'function')) {\n                  _context8.next = 8;\n                  break;\n                }\n\n                this.updateAuthorizationPromise = new Promise( /*#__PURE__*/function () {\n                  var _ref6 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7(resolve, reject) {\n                    var token;\n                    return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n                      while (1) {\n                        switch (_context7.prev = _context7.next) {\n                          case 0:\n                            _context7.prev = 0;\n                            _context7.next = 3;\n                            return _this2.apiToken();\n\n                          case 3:\n                            token = _context7.sent;\n\n                            if (_this2.transport.authorization !== token) {\n                              _this2.transport.authorization = token;\n                            }\n\n                            resolve();\n                            _context7.next = 11;\n                            break;\n\n                          case 8:\n                            _context7.prev = 8;\n                            _context7.t0 = _context7[\"catch\"](0);\n                            reject(_context7.t0);\n\n                          case 11:\n                            _context7.prev = 11;\n                            _this2.updateAuthorizationPromise = null;\n                            return _context7.finish(11);\n\n                          case 14:\n                          case \"end\":\n                            return _context7.stop();\n                        }\n                      }\n                    }, _callee7, null, [[0, 8, 11, 14]]);\n                  }));\n\n                  return function (_x6, _x7) {\n                    return _ref6.apply(this, arguments);\n                  };\n                }());\n                _context8.next = 8;\n                return this.updateAuthorizationPromise;\n\n              case 8:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8, this);\n      }));\n\n      function updateTransportAuthorization() {\n        return _updateTransportAuthorization.apply(this, arguments);\n      }\n\n      return updateTransportAuthorization;\n    }()\n    /**\n     * Add system properties to a query object.\n     * @param {Query} query\n     * @param {string} responseFormat\n     * @returns {void}\n     * @private\n     */\n\n  }, {\n    key: \"patchQueryInternal\",\n    value: function patchQueryInternal(query, responseFormat) {\n      if (responseFormat === ResultType.COMPACT && query.responseFormat !== ResultType.COMPACT) {\n        return _objectSpread(_objectSpread({}, query), {}, {\n          responseFormat: ResultType.COMPACT\n        });\n      } else {\n        return query;\n      }\n    }\n    /**\n     * Process result fetched from the gateway#load method according\n     * to the network protocol.\n     * @param {*} response\n     * @returns ResultSet\n     * @private\n     */\n\n  }, {\n    key: \"loadResponseInternal\",\n    value: function loadResponseInternal(response) {\n      if (response.results.length && response.results[0].query.responseFormat && response.results[0].query.responseFormat === ResultType.COMPACT) {\n        response.results.forEach(function (result, j) {\n          var data = [];\n          result.data.dataset.forEach(function (r) {\n            var row = {};\n            result.data.members.forEach(function (m, i) {\n              row[m] = r[i];\n            });\n            data.push(row);\n          });\n          response.results[j].data = data;\n        });\n      }\n\n      return new ResultSet(response, {\n        parseDateMeasures: this.parseDateMeasures\n      });\n    }\n    /**\n     * Fetch data for the passed `query`. Operates with the\n     * `ApiGateway#load` method to fetch the data.\n     * @param {Query | Query[]} query\n     * @param {LoadMethodOptions | undefined} options\n     * @param {LoadMethodCallback<ResultSet> | undefined} callback\n     * @param {string} responseFormat\n     * @returns {undefined | Promise<ResultSet>}\n     */\n\n  }, {\n    key: \"load\",\n    value: function load(query, options, callback) {\n      var _this3 = this;\n\n      var responseFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ResultType.DEFAULT;\n\n      if (responseFormat === ResultType.COMPACT) {\n        if (Array.isArray(query)) {\n          query = query.map(function (q) {\n            return _this3.patchQueryInternal(q, ResultType.COMPACT);\n          });\n        } else {\n          query = this.patchQueryInternal(query, ResultType.COMPACT);\n        }\n      }\n\n      return this.loadMethod(function () {\n        return _this3.request('load', {\n          query: query,\n          queryType: 'multi'\n        });\n      }, this.loadResponseInternal.bind(this), options, callback);\n    }\n    /**\n     * Allows you to fetch data and receive updates over time. Operates\n     * with the `ApiGateway#load` method to fetch the data.\n     * @link real-time-data-fetch\n     * @param {Query | Query[]} query\n     * @param {LoadMethodOptions | null} options\n     * @param {LoadMethodCallback<ResultSet> | undefined} callback\n     * @param {string} responseFormat\n     * @returns {void}\n     */\n\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(query, options, callback) {\n      var _this4 = this;\n\n      var responseFormat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ResultType.DEFAULT;\n\n      if (responseFormat === ResultType.COMPACT) {\n        if (Array.isArray(query)) {\n          query = query.map(function (q) {\n            return _this4.patchQueryInternal(q, ResultType.COMPACT);\n          });\n        } else {\n          query = this.patchQueryInternal(query, ResultType.COMPACT);\n        }\n      }\n\n      return this.loadMethod(function () {\n        return _this4.request('subscribe', {\n          query: query,\n          queryType: 'multi'\n        });\n      }, this.loadResponseInternal.bind(this), _objectSpread(_objectSpread({}, options), {}, {\n        subscribe: true\n      }), callback);\n    }\n  }, {\n    key: \"sql\",\n    value: function sql(query, options, callback) {\n      var _this5 = this;\n\n      return this.loadMethod(function () {\n        return _this5.request('sql', {\n          query: query\n        });\n      }, function (response) {\n        return Array.isArray(response) ? response.map(function (body) {\n          return new SqlQuery(body);\n        }) : new SqlQuery(response);\n      }, options, callback);\n    }\n  }, {\n    key: \"meta\",\n    value: function meta(options, callback) {\n      var _this6 = this;\n\n      return this.loadMethod(function () {\n        return _this6.request('meta');\n      }, function (body) {\n        return new Meta(body);\n      }, options, callback);\n    }\n  }, {\n    key: \"dryRun\",\n    value: function dryRun(query, options, callback) {\n      var _this7 = this;\n\n      return this.loadMethod(function () {\n        return _this7.request('dry-run', {\n          query: query\n        });\n      }, function (response) {\n        return response;\n      }, options, callback);\n    }\n  }]);\n\n  return CubejsApi;\n}();\n\nvar index = function index(apiToken, options) {\n  return new CubejsApi(apiToken, options);\n};\n\nexport default index;\nexport { CubejsApi, DEFAULT_GRANULARITY, GRANULARITIES, HttpTransport, RequestError, ResultSet, aliasSeries, areQueriesEqual, defaultHeuristics, defaultOrder, flattenFilters, getOrderMembersFromOrder, getQueryMembers, isQueryPresent, moveItemInArray, movePivotItem, removeEmptyQueryFields, validateQuery };","map":null,"metadata":{},"sourceType":"module"}