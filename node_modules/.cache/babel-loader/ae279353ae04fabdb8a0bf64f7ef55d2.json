{"ast":null,"code":"import 'core-js/modules/es.reflect.construct.js';\nimport 'core-js/modules/es.object.keys.js';\nimport 'core-js/modules/es.symbol.js';\nimport 'core-js/modules/es.array.filter.js';\nimport 'core-js/modules/es.object.get-own-property-descriptor.js';\nimport 'core-js/modules/es.array.for-each.js';\nimport 'core-js/modules/web.dom-collections.for-each.js';\nimport 'core-js/modules/es.object.get-own-property-descriptors.js';\nimport 'core-js/modules/es.object.define-properties.js';\nimport 'core-js/modules/es.object.define-property.js';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _classCallCheck from '@babel/runtime/helpers/classCallCheck';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport _inherits from '@babel/runtime/helpers/inherits';\nimport _possibleConstructorReturn from '@babel/runtime/helpers/possibleConstructorReturn';\nimport _getPrototypeOf from '@babel/runtime/helpers/getPrototypeOf';\nimport 'core-js/modules/es.array.iterator.js';\nimport 'core-js/modules/es.object.to-string.js';\nimport 'core-js/modules/es.promise.js';\nimport 'core-js/modules/es.string.iterator.js';\nimport 'core-js/modules/web.dom-collections.iterator.js';\nimport 'core-js/modules/es.array.map.js';\nimport 'core-js/modules/es.date.to-string.js';\nimport 'core-js/modules/es.regexp.to-string.js';\nimport React, { createContext, useRef, useEffect, useContext, useState } from 'react';\nimport { equals, toPairs, fromPairs, uniqBy, prop, indexBy, uniq, pick, clone } from 'ramda';\nimport { isQueryPresent, getQueryMembers, flattenFilters, moveItemInArray, movePivotItem, removeEmptyQueryFields, ResultSet, defaultOrder, validateQuery, defaultHeuristics, areQueriesEqual } from '@cubejs-client/core';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport 'core-js/modules/es.regexp.exec.js';\nimport 'core-js/modules/es.string.split.js';\nimport 'core-js/modules/es.string.replace.js';\nimport 'core-js/modules/es.array.concat.js';\nimport 'core-js/modules/es.object.from-entries.js';\nimport 'core-js/modules/es.object.entries.js';\nimport 'core-js/modules/es.array.is-array.js';\nimport Anser from 'anser';\nimport { encode } from 'html-entities';\nimport _extends from '@babel/runtime/helpers/extends';\nimport _objectWithoutProperties from '@babel/runtime/helpers/objectWithoutProperties';\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport 'core-js/modules/es.function.name.js';\nimport 'core-js/modules/es.array.splice.js';\nimport 'core-js/modules/es.array.sort.js';\nimport 'core-js/modules/es.array.find.js';\nimport 'core-js/modules/es.array.reduce.js';\nvar CubeContext = /*#__PURE__*/createContext(null);\nvar colors = {\n  reset: 'orange',\n  black: 'black',\n  red: 'red',\n  green: 'green',\n  yellow: 'orange',\n  blue: 'blue',\n  magenta: 'magenta',\n  cyan: 'cyan',\n  gray: 'gray',\n  lightgrey: 'lightgrey',\n  darkgrey: 'darkgrey'\n};\nvar anserMap = {\n  'ansi-bright-black': 'black',\n  'ansi-bright-yellow': 'yellow',\n  'ansi-yellow': 'yellow',\n  'ansi-bright-green': 'green',\n  'ansi-green': 'green',\n  'ansi-bright-cyan': 'cyan',\n  'ansi-cyan': 'cyan',\n  'ansi-bright-red': 'red',\n  'ansi-red': 'red',\n  'ansi-bright-magenta': 'magenta',\n  'ansi-magenta': 'magenta',\n  'ansi-white': 'darkgrey'\n};\n\nfunction generateAnsiHTML(txt) {\n  var arr = new Anser().ansiToJson(encode(txt), {\n    use_classes: true\n  });\n  var result = '';\n  var open = false;\n\n  for (var index = 0; index < arr.length; ++index) {\n    var c = arr[index];\n    var content = c.content;\n    var fg = c.fg;\n    var contentParts = content.split('\\n');\n\n    for (var j = 0; j < contentParts.length; ++j) {\n      if (!open) {\n        result += '<span data-ansi-line=\"true\">';\n        open = true;\n      }\n\n      var part = contentParts[j].replace('\\r', '');\n      var color = colors[anserMap[fg]];\n\n      if (color != null) {\n        result += \"<span style=\\\"color: \".concat(color, \";\\\">\").concat(part, \"</span>\");\n      } else {\n        if (fg != null) {\n          console.log('Missing color mapping: ', fg);\n        }\n\n        result += \"<span>\".concat(part, \"</span>\");\n      }\n\n      if (j < contentParts.length - 1) {\n        result += '</span>';\n        open = false;\n        result += '<br/>';\n      }\n    }\n  }\n\n  if (open) {\n    result += '</span>';\n  }\n\n  return result;\n}\n\nfunction removeEmpty(obj) {\n  if (_typeof(obj) !== 'object') {\n    return obj;\n  }\n\n  return Object.fromEntries(Object.entries(obj).filter(function (_ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        v = _ref2[1];\n\n    return v != null;\n  }).map(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n        k = _ref4[0],\n        v = _ref4[1];\n\n    if (Array.isArray(v)) {\n      return [k, v.map(removeEmpty)];\n    }\n\n    return [k, _typeof(v) === 'object' ? removeEmpty(v) : v];\n  }));\n}\n\nfunction ownKeys$6(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$6(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper$1(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct$1() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar QueryRenderer = /*#__PURE__*/function (_React$Component) {\n  _inherits(QueryRenderer, _React$Component);\n\n  var _super = _createSuper$1(QueryRenderer);\n\n  function QueryRenderer(props) {\n    var _this;\n\n    _classCallCheck(this, QueryRenderer);\n\n    _this = _super.call(this, props);\n    _this.state = {};\n    _this.mutexObj = {};\n    return _this;\n  }\n\n  _createClass(QueryRenderer, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this$props = this.props,\n          query = _this$props.query,\n          queries = _this$props.queries;\n\n      if (query) {\n        this.load(query);\n      }\n\n      if (queries) {\n        this.loadQueries(queries);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _this$props2 = this.props,\n          query = _this$props2.query,\n          queries = _this$props2.queries,\n          render = _this$props2.render,\n          cubejsApi = _this$props2.cubejsApi,\n          loadSql = _this$props2.loadSql,\n          updateOnlyOnStateChange = _this$props2.updateOnlyOnStateChange;\n\n      if (!updateOnlyOnStateChange) {\n        return true;\n      }\n\n      return !equals(nextProps.query, query) || !equals(nextProps.queries, queries) || (nextProps.render == null || render == null) && nextProps.render !== render || nextProps.cubejsApi !== cubejsApi || nextProps.loadSql !== loadSql || !equals(nextState, this.state) || nextProps.updateOnlyOnStateChange !== updateOnlyOnStateChange;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      var _this$props3 = this.props,\n          query = _this$props3.query,\n          queries = _this$props3.queries;\n\n      if (!equals(prevProps.query, query)) {\n        this.load(query);\n      }\n\n      if (!equals(prevProps.queries, queries)) {\n        this.loadQueries(queries);\n      }\n    }\n  }, {\n    key: \"cubejsApi\",\n    value: function cubejsApi() {\n      // eslint-disable-next-line react/destructuring-assignment\n      return this.props.cubejsApi || this.context && this.context.cubejsApi;\n    }\n  }, {\n    key: \"load\",\n    value: function load(query) {\n      var _this2 = this;\n\n      var resetResultSetOnChange = this.props.resetResultSetOnChange;\n      this.setState(_objectSpread$6({\n        isLoading: true,\n        error: null,\n        sqlQuery: null\n      }, resetResultSetOnChange ? {\n        resultSet: null\n      } : {}));\n      var loadSql = this.props.loadSql;\n      var cubejsApi = this.cubejsApi();\n\n      if (query && isQueryPresent(query)) {\n        if (loadSql === 'only') {\n          cubejsApi.sql(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'sql'\n          }).then(function (sqlQuery) {\n            return _this2.setState({\n              sqlQuery: sqlQuery,\n              error: null,\n              isLoading: false\n            });\n          })[\"catch\"](function (error) {\n            return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {\n              resultSet: null\n            } : {}), {}, {\n              error: error,\n              isLoading: false\n            }));\n          });\n        } else if (loadSql) {\n          Promise.all([cubejsApi.sql(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'sql'\n          }), cubejsApi.load(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'query'\n          })]).then(function (_ref) {\n            var _ref2 = _slicedToArray(_ref, 2),\n                sqlQuery = _ref2[0],\n                resultSet = _ref2[1];\n\n            return _this2.setState({\n              sqlQuery: sqlQuery,\n              resultSet: resultSet,\n              error: null,\n              isLoading: false\n            });\n          })[\"catch\"](function (error) {\n            return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {\n              resultSet: null\n            } : {}), {}, {\n              error: error,\n              isLoading: false\n            }));\n          });\n        } else {\n          cubejsApi.load(query, {\n            mutexObj: this.mutexObj,\n            mutexKey: 'query'\n          }).then(function (resultSet) {\n            return _this2.setState({\n              resultSet: resultSet,\n              error: null,\n              isLoading: false\n            });\n          })[\"catch\"](function (error) {\n            return _this2.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {\n              resultSet: null\n            } : {}), {}, {\n              error: error,\n              isLoading: false\n            }));\n          });\n        }\n      }\n    }\n  }, {\n    key: \"loadQueries\",\n    value: function loadQueries(queries) {\n      var _this3 = this;\n\n      var cubejsApi = this.cubejsApi();\n      var resetResultSetOnChange = this.props.resetResultSetOnChange;\n      this.setState(_objectSpread$6(_objectSpread$6({\n        isLoading: true\n      }, resetResultSetOnChange ? {\n        resultSet: null\n      } : {}), {}, {\n        error: null\n      }));\n      var resultPromises = Promise.all(toPairs(queries).map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            name = _ref4[0],\n            query = _ref4[1];\n\n        return cubejsApi.load(query, {\n          mutexObj: _this3.mutexObj,\n          mutexKey: name\n        }).then(function (r) {\n          return [name, r];\n        });\n      }));\n      resultPromises.then(function (resultSet) {\n        return _this3.setState({\n          resultSet: fromPairs(resultSet),\n          error: null,\n          isLoading: false\n        });\n      })[\"catch\"](function (error) {\n        return _this3.setState(_objectSpread$6(_objectSpread$6({}, resetResultSetOnChange ? {\n          resultSet: null\n        } : {}), {}, {\n          error: error,\n          isLoading: false\n        }));\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$state = this.state,\n          error = _this$state.error,\n          queries = _this$state.queries,\n          resultSet = _this$state.resultSet,\n          isLoading = _this$state.isLoading,\n          sqlQuery = _this$state.sqlQuery;\n      var render = this.props.render;\n      var loadState = {\n        error: error ? new Error(generateAnsiHTML(error.message || error.toString())) : null,\n        resultSet: queries ? resultSet || {} : resultSet,\n        loadingState: {\n          isLoading: isLoading\n        },\n        sqlQuery: sqlQuery\n      };\n\n      if (render) {\n        return render(loadState);\n      }\n\n      return null;\n    }\n  }], [{\n    key: \"isQueryPresent\",\n    value: // @deprected use `isQueryPresent` from `@cubejs-client/core`\n    function isQueryPresent$1(query) {\n      return isQueryPresent(query);\n    }\n  }]);\n\n  return QueryRenderer;\n}(React.Component);\n\nQueryRenderer.contextType = CubeContext;\nQueryRenderer.defaultProps = {\n  cubejsApi: null,\n  query: null,\n  render: null,\n  queries: null,\n  loadSql: null,\n  updateOnlyOnStateChange: false,\n  resetResultSetOnChange: true\n};\nvar _excluded$1 = [\"query\"];\n\nfunction ownKeys$5(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$5(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nvar QueryRendererWithTotals = function QueryRendererWithTotals(_ref) {\n  var query = _ref.query,\n      restProps = _objectWithoutProperties(_ref, _excluded$1);\n\n  return /*#__PURE__*/React.createElement(QueryRenderer, _extends({\n    queries: {\n      totals: _objectSpread$5(_objectSpread$5({}, query), {}, {\n        dimensions: [],\n        timeDimensions: query.timeDimensions ? query.timeDimensions.map(function (td) {\n          return _objectSpread$5(_objectSpread$5({}, td), {}, {\n            granularity: null\n          });\n        }) : undefined\n      }),\n      main: query\n    }\n  }, restProps));\n};\n\nQueryRendererWithTotals.defaultProps = {\n  query: null,\n  render: null,\n  queries: null,\n  loadSql: null\n};\n\nfunction ownKeys$4(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$4(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nvar granularities = [{\n  name: undefined,\n  title: 'w/o grouping'\n}, {\n  name: 'second',\n  title: 'Second'\n}, {\n  name: 'minute',\n  title: 'Minute'\n}, {\n  name: 'hour',\n  title: 'Hour'\n}, {\n  name: 'day',\n  title: 'Day'\n}, {\n  name: 'week',\n  title: 'Week'\n}, {\n  name: 'month',\n  title: 'Month'\n}, {\n  name: 'quarter',\n  title: 'Quarter'\n}, {\n  name: 'year',\n  title: 'Year'\n}];\n\nvar QueryBuilder = /*#__PURE__*/function (_React$Component) {\n  _inherits(QueryBuilder, _React$Component);\n\n  var _super = _createSuper(QueryBuilder);\n\n  function QueryBuilder(props) {\n    var _this;\n\n    _classCallCheck(this, QueryBuilder);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"fetchMeta\", /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var meta, metaError, metaErrorStack, _error$response, _error$response$stack;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (_this.cubejsApi()) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 2:\n              metaError = null;\n              metaErrorStack = null;\n              _context.prev = 4;\n\n              _this.setState({\n                isFetchingMeta: true\n              });\n\n              _context.next = 8;\n              return _this.cubejsApi().meta();\n\n            case 8:\n              meta = _context.sent;\n              _context.next = 15;\n              break;\n\n            case 11:\n              _context.prev = 11;\n              _context.t0 = _context[\"catch\"](4);\n              metaError = _context.t0;\n              metaErrorStack = ((_error$response = _context.t0.response) === null || _error$response === void 0 ? void 0 : (_error$response$stack = _error$response.stack) === null || _error$response$stack === void 0 ? void 0 : _error$response$stack.replace(_context.t0.message || '', '')) || '';\n\n            case 15:\n              _this.setState({\n                meta: meta,\n                metaError: metaError ? new Error(generateAnsiHTML(metaError.message || metaError.toString())) : null,\n                metaErrorStack: metaErrorStack,\n                isFetchingMeta: false\n              }, function () {\n                // Run update query to force viz state update\n                // This will catch any new missing members, and also validate the query against the new meta\n                _this.updateQuery({});\n              });\n\n            case 16:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[4, 11]]);\n    })));\n\n    _this.state = _objectSpread$4(_objectSpread$4({\n      query: props.defaultQuery || props.query,\n      chartType: props.defaultChartType,\n      validatedQuery: props.query,\n      // deprecated, validatedQuery should not be set until after dry-run for safety\n      missingMembers: [],\n      // todo: rename to `isMetaReady`\n      isFetchingMeta: true,\n      dryRunResponse: null\n    }, props.vizState), props.initialVizState);\n    _this.mutexObj = {};\n    _this.orderMembersOrderKeys = [];\n    return _this;\n  }\n\n  _createClass(QueryBuilder, [{\n    key: \"componentDidMount\",\n    value: function () {\n      var _componentDidMount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.prevContext = this.context;\n                _context2.next = 3;\n                return this.fetchMeta();\n\n              case 3:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function componentDidMount() {\n        return _componentDidMount.apply(this, arguments);\n      }\n\n      return componentDidMount;\n    }()\n  }, {\n    key: \"componentDidUpdate\",\n    value: function () {\n      var _componentDidUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(prevProps) {\n        var _this$prevContext,\n            _this$context,\n            _this2 = this;\n\n        var _this$props, schemaVersion, onSchemaChange, meta, newMeta;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _this$props = this.props, schemaVersion = _this$props.schemaVersion, onSchemaChange = _this$props.onSchemaChange;\n                meta = this.state.meta;\n\n                if (!(((_this$prevContext = this.prevContext) === null || _this$prevContext === void 0 ? void 0 : _this$prevContext.cubejsApi) !== ((_this$context = this.context) === null || _this$context === void 0 ? void 0 : _this$context.cubejsApi))) {\n                  _context4.next = 6;\n                  break;\n                }\n\n                this.prevContext = this.context;\n                _context4.next = 6;\n                return this.fetchMeta();\n\n              case 6:\n                if (!(prevProps.schemaVersion !== schemaVersion)) {\n                  _context4.next = 17;\n                  break;\n                }\n\n                _context4.prev = 7;\n                _context4.next = 10;\n                return this.cubejsApi().meta();\n\n              case 10:\n                newMeta = _context4.sent;\n\n                if (!equals(newMeta, meta) && typeof onSchemaChange === 'function') {\n                  onSchemaChange({\n                    schemaVersion: schemaVersion,\n                    refresh: function () {\n                      var _refresh = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n                        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n                          while (1) {\n                            switch (_context3.prev = _context3.next) {\n                              case 0:\n                                _context3.next = 2;\n                                return _this2.fetchMeta();\n\n                              case 2:\n                              case \"end\":\n                                return _context3.stop();\n                            }\n                          }\n                        }, _callee3);\n                      }));\n\n                      function refresh() {\n                        return _refresh.apply(this, arguments);\n                      }\n\n                      return refresh;\n                    }()\n                  });\n                }\n\n                _context4.next = 17;\n                break;\n\n              case 14:\n                _context4.prev = 14;\n                _context4.t0 = _context4[\"catch\"](7); // eslint-disable-next-line\n\n                this.setState({\n                  metaError: _context4.t0\n                });\n\n              case 17:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[7, 14]]);\n      }));\n\n      function componentDidUpdate(_x) {\n        return _componentDidUpdate.apply(this, arguments);\n      }\n\n      return componentDidUpdate;\n    }()\n  }, {\n    key: \"cubejsApi\",\n    value: function cubejsApi() {\n      var cubejsApi = this.props.cubejsApi; // eslint-disable-next-line react/destructuring-assignment\n\n      return cubejsApi || this.context && this.context.cubejsApi;\n    }\n  }, {\n    key: \"getMissingMembers\",\n    value: function getMissingMembers(query, meta) {\n      if (!meta) {\n        return [];\n      }\n\n      return getQueryMembers(query).map(function (member) {\n        var resolvedMember = meta.resolveMember(member, ['measures', 'dimensions', 'segments']);\n\n        if (resolvedMember.error) {\n          return member;\n        }\n\n        return false;\n      }).filter(Boolean);\n    }\n  }, {\n    key: \"isQueryPresent\",\n    value: function isQueryPresent() {\n      var query = this.state.query;\n      return QueryRenderer.isQueryPresent(query);\n    }\n  }, {\n    key: \"prepareRenderProps\",\n    value: function prepareRenderProps(queryRendererProps) {\n      var _this3 = this;\n\n      var getName = function getName(member) {\n        return member.name;\n      };\n\n      var toTimeDimension = function toTimeDimension(member) {\n        var rangeSelection = member.compareDateRange ? {\n          compareDateRange: member.compareDateRange\n        } : {\n          dateRange: member.dateRange\n        };\n        return removeEmpty(_objectSpread$4({\n          dimension: member.dimension.name,\n          granularity: member.granularity\n        }, rangeSelection));\n      };\n\n      var toFilter = function toFilter(member) {\n        var _member$member, _member$dimension;\n\n        return {\n          member: ((_member$member = member.member) === null || _member$member === void 0 ? void 0 : _member$member.name) || ((_member$dimension = member.dimension) === null || _member$dimension === void 0 ? void 0 : _member$dimension.name),\n          operator: member.operator,\n          values: member.values\n        };\n      };\n\n      var updateMethods = function updateMethods(memberType) {\n        var toQuery = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getName;\n        return {\n          add: function add(member) {\n            var query = _this3.state.query;\n\n            _this3.updateQuery(_defineProperty({}, memberType, (query[memberType] || []).concat(toQuery(member))));\n          },\n          remove: function remove(member) {\n            var query = _this3.state.query;\n            return _this3.updateQuery(_defineProperty({}, memberType, (query[memberType] || []).filter(function (_, index) {\n              return index !== member.index;\n            })));\n          },\n          update: function update(member, updateWith) {\n            var query = _this3.state.query;\n            var members = (query[memberType] || []).concat([]);\n            members.splice(member.index, 1, toQuery(updateWith));\n            return _this3.updateQuery(_defineProperty({}, memberType, members));\n          }\n        };\n      };\n\n      var _this$state = this.state,\n          meta = _this$state.meta,\n          metaError = _this$state.metaError,\n          query = _this$state.query,\n          queryError = _this$state.queryError,\n          chartType = _this$state.chartType,\n          pivotConfig = _this$state.pivotConfig,\n          validatedQuery = _this$state.validatedQuery,\n          missingMembers = _this$state.missingMembers,\n          isFetchingMeta = _this$state.isFetchingMeta,\n          dryRunResponse = _this$state.dryRunResponse,\n          metaErrorStack = _this$state.metaErrorStack;\n      var flatFilters = uniqBy(function (filter) {\n        return \"\".concat(prop('member', filter)).concat(prop('operator', filter));\n      }, flattenFilters(meta && query.filters || []).map(function (filter) {\n        return _objectSpread$4(_objectSpread$4({}, filter), {}, {\n          member: filter.member || filter.dimension\n        });\n      }));\n      var filters = flatFilters.map(function (m, i) {\n        return _objectSpread$4(_objectSpread$4({}, m), {}, {\n          dimension: meta.resolveMember(m.member || m.dimension, ['dimensions', 'measures']),\n          operators: meta.filterOperatorsForMember(m.member || m.dimension, ['dimensions', 'measures']),\n          index: i\n        });\n      });\n      var measures = QueryBuilder.resolveMember('measures', this.state);\n      var dimensions = QueryBuilder.resolveMember('dimensions', this.state);\n      var timeDimensions = QueryBuilder.resolveMember('timeDimensions', this.state);\n      var segments = (meta && query.segments || []).map(function (m, i) {\n        return _objectSpread$4({\n          index: i\n        }, meta.resolveMember(m, 'segments'));\n      });\n      var availableMeasures = [];\n      var availableDimensions = [];\n      var availableSegments = [];\n      var availableFilterMembers = [];\n      var availableMembers = (meta === null || meta === void 0 ? void 0 : meta.membersGroupedByCube()) || {\n        measures: [],\n        dimensions: [],\n        segments: [],\n        timeDimensions: []\n      };\n\n      if (meta) {\n        availableMeasures = meta.membersForQuery(query, 'measures');\n        availableDimensions = meta.membersForQuery(query, 'dimensions');\n        availableSegments = meta.membersForQuery(query, 'segments');\n        var indexedMeasures = indexBy(prop('cubeName'), availableMembers.measures);\n        var indexedDimensions = indexBy(prop('cubeName'), availableMembers.dimensions);\n        var cubeNames = uniq([].concat(_toConsumableArray(Object.keys(indexedMeasures)), _toConsumableArray(Object.keys(indexedDimensions)))).sort();\n        availableFilterMembers = cubeNames.map(function (name) {\n          var _indexedMeasures$name, _indexedDimensions$na;\n\n          var cube = indexedMeasures[name] || indexedDimensions[name];\n          return _objectSpread$4(_objectSpread$4({}, cube), {}, {\n            members: [].concat(_toConsumableArray((_indexedMeasures$name = indexedMeasures[name]) === null || _indexedMeasures$name === void 0 ? void 0 : _indexedMeasures$name.members), _toConsumableArray((_indexedDimensions$na = indexedDimensions[name]) === null || _indexedDimensions$na === void 0 ? void 0 : _indexedDimensions$na.members)).sort(function (a, b) {\n              return a.shortTitle > b.shortTitle ? 1 : -1;\n            })\n          });\n        });\n      }\n\n      var activeOrder = Array.isArray(query.order) ? Object.fromEntries(query.order) : query.order;\n      var members = [].concat(_toConsumableArray(measures), _toConsumableArray(dimensions), _toConsumableArray(timeDimensions.map(function (_ref2) {\n        var dimension = _ref2.dimension;\n        return dimension;\n      })));\n      var orderMembers = uniqBy(prop('id'), _toConsumableArray(members.map(function (_ref3) {\n        var name = _ref3.name,\n            title = _ref3.title;\n        return {\n          id: name,\n          title: title,\n          order: (activeOrder === null || activeOrder === void 0 ? void 0 : activeOrder[name]) || 'none'\n        };\n      })));\n\n      if (this.orderMembersOrderKeys.length !== orderMembers.length) {\n        this.orderMembersOrderKeys = orderMembers.map(function (_ref4) {\n          var id = _ref4.id;\n          return id;\n        });\n      }\n\n      if (this.orderMembersOrderKeys.length) {\n        // Preserve order until the members change or manually re-ordered\n        // This is needed so that when an order member becomes active, it doesn't jump to the top of the list\n        orderMembers = (this.orderMembersOrderKeys || []).map(function (id) {\n          return orderMembers.find(function (member) {\n            return member.id === id;\n          });\n        });\n      }\n\n      return _objectSpread$4({\n        meta: meta,\n        metaError: metaError,\n        metaErrorStack: metaErrorStack,\n        query: query,\n        error: queryError,\n        // Match same name as QueryRenderer prop\n        validatedQuery: validatedQuery,\n        isQueryPresent: this.isQueryPresent(),\n        chartType: chartType,\n        measures: measures,\n        dimensions: dimensions,\n        timeDimensions: timeDimensions,\n        segments: segments,\n        filters: filters,\n        orderMembers: orderMembers,\n        availableMeasures: availableMeasures,\n        availableDimensions: availableDimensions,\n        availableTimeDimensions: availableDimensions.filter(function (m) {\n          return m.type === 'time';\n        }),\n        availableSegments: availableSegments,\n        availableMembers: availableMembers,\n        availableFilterMembers: availableFilterMembers,\n        updateQuery: function updateQuery(queryUpdate) {\n          return _this3.updateQuery(queryUpdate);\n        },\n        updateMeasures: updateMethods('measures'),\n        updateDimensions: updateMethods('dimensions'),\n        updateSegments: updateMethods('segments'),\n        updateTimeDimensions: updateMethods('timeDimensions', toTimeDimension),\n        updateFilters: updateMethods('filters', toFilter),\n        updateChartType: function updateChartType(newChartType) {\n          return _this3.updateVizState({\n            chartType: newChartType\n          });\n        },\n        updateOrder: {\n          set: function set(memberId) {\n            var newOrder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'asc';\n\n            _this3.updateQuery({\n              order: orderMembers.map(function (orderMember) {\n                return _objectSpread$4(_objectSpread$4({}, orderMember), {}, {\n                  order: orderMember.id === memberId ? newOrder : orderMember.order\n                });\n              }).reduce(function (acc, _ref5) {\n                var id = _ref5.id,\n                    order = _ref5.order;\n                return order !== 'none' ? [].concat(_toConsumableArray(acc), [[id, order]]) : acc;\n              }, [])\n            });\n          },\n          update: function update(order) {\n            _this3.updateQuery({\n              order: order\n            });\n          },\n          reorder: function reorder(sourceIndex, destinationIndex) {\n            if (sourceIndex == null || destinationIndex == null) {\n              return;\n            }\n\n            var nextArray = moveItemInArray(orderMembers, sourceIndex, destinationIndex);\n            _this3.orderMembersOrderKeys = nextArray.map(function (_ref6) {\n              var id = _ref6.id;\n              return id;\n            });\n\n            _this3.updateQuery({\n              order: nextArray.reduce(function (acc, _ref7) {\n                var id = _ref7.id,\n                    order = _ref7.order;\n                return order !== 'none' ? [].concat(_toConsumableArray(acc), [[id, order]]) : acc;\n              }, [])\n            });\n          }\n        },\n        pivotConfig: pivotConfig,\n        updatePivotConfig: {\n          moveItem: function moveItem(_ref8) {\n            var sourceIndex = _ref8.sourceIndex,\n                destinationIndex = _ref8.destinationIndex,\n                sourceAxis = _ref8.sourceAxis,\n                destinationAxis = _ref8.destinationAxis;\n\n            _this3.updateVizState({\n              pivotConfig: movePivotItem(pivotConfig, sourceIndex, destinationIndex, sourceAxis, destinationAxis)\n            });\n          },\n          update: function update(config) {\n            var limit = config.limit;\n\n            _this3.updateVizState(_objectSpread$4({\n              pivotConfig: _objectSpread$4(_objectSpread$4({}, pivotConfig), config)\n            }, limit ? {\n              query: _objectSpread$4(_objectSpread$4({}, query), {}, {\n                limit: limit\n              })\n            } : null));\n          }\n        },\n        missingMembers: missingMembers,\n        refresh: this.fetchMeta,\n        isFetchingMeta: isFetchingMeta,\n        dryRunResponse: dryRunResponse\n      }, queryRendererProps);\n    }\n  }, {\n    key: \"updateQuery\",\n    value: function updateQuery(queryUpdate) {\n      var query = this.state.query;\n      this.updateVizState({\n        query: removeEmptyQueryFields(_objectSpread$4(_objectSpread$4({}, query), queryUpdate))\n      });\n    }\n  }, {\n    key: \"updateVizState\",\n    value: function () {\n      var _updateVizState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(state) {\n        var _this4 = this;\n\n        var _this$props2, setQuery, setVizState, _this$state2, stateQuery, statePivotConfig, chartType, meta, finalState, vizStateSent, handleVizStateChange, runSetters, shouldFetchDryRun, response;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _this$props2 = this.props, setQuery = _this$props2.setQuery, setVizState = _this$props2.setVizState;\n                _this$state2 = this.state, stateQuery = _this$state2.query, statePivotConfig = _this$state2.pivotConfig, chartType = _this$state2.chartType, meta = _this$state2.meta;\n                finalState = this.applyStateChangeHeuristics(state);\n\n                if (!finalState.query) {\n                  finalState.query = _objectSpread$4({}, stateQuery);\n                }\n\n                vizStateSent = null;\n\n                handleVizStateChange = function handleVizStateChange(currentState) {\n                  var onVizStateChanged = _this4.props.onVizStateChanged;\n\n                  if (onVizStateChanged) {\n                    var newVizState = pick(['chartType', 'pivotConfig', 'query'], currentState); // Don't run callbacks more than once unless the viz state has changed since last time\n\n                    if (!vizStateSent || !equals(vizStateSent, newVizState)) {\n                      onVizStateChanged(newVizState); // use clone to make sure we don't save object references\n\n                      vizStateSent = clone(newVizState);\n                    }\n                  }\n                }; // deprecated, setters replaced by onVizStateChanged\n\n\n                runSetters = function runSetters(currentState) {\n                  if (setVizState) {\n                    setVizState(pick(['chartType', 'pivotConfig', 'query'], currentState));\n                  }\n\n                  if (currentState.query && setQuery) {\n                    setQuery(currentState.query);\n                  }\n                };\n\n                if (finalState.shouldApplyHeuristicOrder) {\n                  finalState.query.order = defaultOrder(finalState.query);\n                }\n\n                finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(finalState.query, finalState.pivotConfig !== undefined ? finalState.pivotConfig : statePivotConfig);\n                finalState.missingMembers = this.getMissingMembers(finalState.query, meta);\n                finalState.chartType = finalState.chartType || state.chartType || chartType; // deprecated\n\n                runSetters(_objectSpread$4(_objectSpread$4({}, state), {}, {\n                  query: finalState.query\n                })); // Update optimistically so that UI does not stutter\n\n                this.setState(_objectSpread$4(_objectSpread$4({}, finalState), {}, {\n                  queryError: null\n                }));\n                handleVizStateChange(finalState);\n                shouldFetchDryRun = !equals(pick(['measures', 'dimensions', 'timeDimensions'], stateQuery), pick(['measures', 'dimensions', 'timeDimensions'], finalState.query));\n\n                if (!(shouldFetchDryRun && isQueryPresent(finalState.query) && finalState.missingMembers.length === 0)) {\n                  _context5.next = 30;\n                  break;\n                }\n\n                _context5.prev = 16;\n                _context5.next = 19;\n                return this.cubejsApi().dryRun(finalState.query, {\n                  mutexObj: this.mutexObj\n                });\n\n              case 19:\n                response = _context5.sent;\n\n                if (finalState.shouldApplyHeuristicOrder) {\n                  finalState.query.order = (response.queryOrder || []).reduce(function (memo, current) {\n                    return _objectSpread$4(_objectSpread$4({}, memo), current);\n                  }, {});\n                }\n\n                finalState.pivotConfig = ResultSet.getNormalizedPivotConfig(response.pivotQuery, finalState.pivotConfig);\n                finalState.validatedQuery = this.validatedQuery(finalState);\n                finalState.dryRunResponse = response; // deprecated\n\n                if (isQueryPresent(stateQuery)) {\n                  runSetters(_objectSpread$4(_objectSpread$4({}, this.state), finalState));\n                }\n\n                _context5.next = 30;\n                break;\n\n              case 27:\n                _context5.prev = 27;\n                _context5.t0 = _context5[\"catch\"](16);\n                this.setState({\n                  queryError: new Error(generateAnsiHTML(_context5.t0.message || _context5.t0.toString()))\n                });\n\n              case 30:\n                this.setState(finalState, function () {\n                  return handleVizStateChange(_this4.state);\n                });\n\n              case 31:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[16, 27]]);\n      }));\n\n      function updateVizState(_x2) {\n        return _updateVizState.apply(this, arguments);\n      }\n\n      return updateVizState;\n    }()\n  }, {\n    key: \"validatedQuery\",\n    value: function validatedQuery(state) {\n      var _ref9 = state || this.state,\n          query = _ref9.query;\n\n      return validateQuery(query);\n    }\n  }, {\n    key: \"defaultHeuristics\",\n    value: function defaultHeuristics$1(newState) {\n      var _this$state3 = this.state,\n          query = _this$state3.query,\n          sessionGranularity = _this$state3.sessionGranularity,\n          meta = _this$state3.meta;\n      return defaultHeuristics(newState, query, {\n        meta: meta,\n        sessionGranularity: sessionGranularity || 'day'\n      });\n    }\n  }, {\n    key: \"applyStateChangeHeuristics\",\n    value: function applyStateChangeHeuristics(newState) {\n      var _this$props3 = this.props,\n          stateChangeHeuristics = _this$props3.stateChangeHeuristics,\n          disableHeuristics = _this$props3.disableHeuristics;\n\n      if (disableHeuristics) {\n        return newState;\n      }\n\n      return stateChangeHeuristics && stateChangeHeuristics(this.state, newState) || this.defaultHeuristics(newState);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this5 = this;\n\n      var query = this.state.query;\n      var _this$props4 = this.props,\n          cubejsApi = _this$props4.cubejsApi,\n          _render = _this$props4.render,\n          wrapWithQueryRenderer = _this$props4.wrapWithQueryRenderer;\n\n      if (wrapWithQueryRenderer) {\n        return /*#__PURE__*/React.createElement(QueryRenderer, {\n          query: query,\n          cubejsApi: cubejsApi,\n          resetResultSetOnChange: false,\n          render: function render(queryRendererProps) {\n            if (_render) {\n              return _render(_this5.prepareRenderProps(queryRendererProps));\n            }\n\n            return null;\n          }\n        });\n      } else {\n        if (_render) {\n          return _render(this.prepareRenderProps());\n        }\n\n        return null;\n      }\n    }\n  }], [{\n    key: \"getDerivedStateFromProps\",\n    value: // This is an anti-pattern, only kept for backward compatibility\n    // https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#anti-pattern-unconditionally-copying-props-to-state\n    function getDerivedStateFromProps(props, state) {\n      if (props.query || props.vizState) {\n        var nextState = _objectSpread$4(_objectSpread$4({}, state), props.vizState || {});\n\n        if (Array.isArray(props.query)) {\n          throw new Error('Array of queries is not supported.');\n        }\n\n        return _objectSpread$4(_objectSpread$4({}, nextState), {}, {\n          query: _objectSpread$4(_objectSpread$4({}, nextState.query), props.query || {})\n        });\n      }\n\n      return null;\n    }\n  }, {\n    key: \"resolveMember\",\n    value: function resolveMember(type, _ref10) {\n      var meta = _ref10.meta,\n          query = _ref10.query;\n\n      if (!meta) {\n        return [];\n      }\n\n      if (Array.isArray(query)) {\n        return query.reduce(function (memo, currentQuery) {\n          return memo.concat(QueryBuilder.resolveMember(type, {\n            meta: meta,\n            query: currentQuery\n          }));\n        }, []);\n      }\n\n      if (type === 'timeDimensions') {\n        return (query.timeDimensions || []).map(function (m, index) {\n          return _objectSpread$4(_objectSpread$4({}, m), {}, {\n            dimension: _objectSpread$4(_objectSpread$4({}, meta.resolveMember(m.dimension, 'dimensions')), {}, {\n              granularities: granularities\n            }),\n            index: index\n          });\n        });\n      }\n\n      return (query[type] || []).map(function (m, index) {\n        return _objectSpread$4({\n          index: index\n        }, meta.resolveMember(m, type));\n      });\n    }\n  }]);\n\n  return QueryBuilder;\n}(React.Component);\n\n_defineProperty(QueryBuilder, \"contextType\", CubeContext);\n\nQueryBuilder.defaultProps = {\n  cubejsApi: null,\n  stateChangeHeuristics: null,\n  disableHeuristics: false,\n  render: null,\n  wrapWithQueryRenderer: true,\n  defaultChartType: 'line',\n  defaultQuery: {},\n  initialVizState: null,\n  onVizStateChanged: null,\n  // deprecated\n  query: null,\n  setQuery: null,\n  vizState: null,\n  setVizState: null\n};\n\nfunction CubeProvider(_ref) {\n  var cubejsApi = _ref.cubejsApi,\n      children = _ref.children;\n  return /*#__PURE__*/React.createElement(CubeContext.Provider, {\n    value: {\n      cubejsApi: cubejsApi\n    }\n  }, children);\n}\n\nfunction useDeepCompareMemoize(value) {\n  var ref = useRef([]);\n\n  if (!equals(value, ref.current)) {\n    ref.current = value;\n  }\n\n  return ref.current;\n}\n\nfunction useIsMounted() {\n  var isMounted = useRef(false);\n  useEffect(function () {\n    isMounted.current = true;\n    return function () {\n      isMounted.current = false;\n    };\n  }, []);\n  return function () {\n    return isMounted.current;\n  };\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction useCubeFetch(method) {\n  var _options$query;\n\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var isMounted = useIsMounted();\n  var context = useContext(CubeContext);\n  var mutexRef = useRef({});\n\n  var _useState = useState({\n    isLoading: false,\n    response: null\n  }),\n      _useState2 = _slicedToArray(_useState, 2),\n      response = _useState2[0],\n      setResponse = _useState2[1];\n\n  var _useState3 = useState(null),\n      _useState4 = _slicedToArray(_useState3, 2),\n      error = _useState4[0],\n      setError = _useState4[1];\n\n  var _options$skip = options.skip,\n      skip = _options$skip === void 0 ? false : _options$skip;\n\n  function load() {\n    return _load.apply(this, arguments);\n  }\n\n  function _load() {\n    _load = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var loadOptions,\n          ignoreSkip,\n          cubejsApi,\n          query,\n          queryCondition,\n          coreOptions,\n          args,\n          _response,\n          _args = arguments;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              loadOptions = _args.length > 0 && _args[0] !== undefined ? _args[0] : {};\n              ignoreSkip = _args.length > 1 && _args[1] !== undefined ? _args[1] : false;\n              cubejsApi = options.cubejsApi || (context === null || context === void 0 ? void 0 : context.cubejsApi);\n              query = loadOptions.query || options.query;\n              queryCondition = method === 'meta' ? true : query && isQueryPresent(query);\n\n              if (!(cubejsApi && (ignoreSkip || !skip) && queryCondition)) {\n                _context.next = 20;\n                break;\n              }\n\n              setError(null);\n              setResponse({\n                isLoading: true,\n                response: null\n              });\n              coreOptions = {\n                mutexObj: mutexRef.current,\n                mutexKey: method\n              };\n              args = method === 'meta' ? [coreOptions] : [query, coreOptions];\n              _context.prev = 10;\n              _context.next = 13;\n              return cubejsApi[method].apply(cubejsApi, args);\n\n            case 13:\n              _response = _context.sent;\n\n              if (isMounted()) {\n                setResponse({\n                  response: _response,\n                  isLoading: false\n                });\n              }\n\n              _context.next = 20;\n              break;\n\n            case 17:\n              _context.prev = 17;\n              _context.t0 = _context[\"catch\"](10);\n\n              if (isMounted()) {\n                setError(_context.t0);\n                setResponse({\n                  isLoading: false,\n                  response: null\n                });\n              }\n\n            case 20:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[10, 17]]);\n    }));\n    return _load.apply(this, arguments);\n  }\n\n  useEffect(function () {\n    load();\n  }, useDeepCompareMemoize([Object.keys(((_options$query = options.query) === null || _options$query === void 0 ? void 0 : _options$query.order) || {}), options, context]));\n  return _objectSpread$3(_objectSpread$3({}, response), {}, {\n    error: error,\n    refetch: function refetch(options) {\n      return load(options, true);\n    }\n  });\n}\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction useCubeSql(query) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCubeFetch('sql', _objectSpread$2(_objectSpread$2({}, options), {}, {\n    query: query\n  }));\n}\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction useDryRun(query) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCubeFetch('dryRun', _objectSpread$1(_objectSpread$1({}, options), {}, {\n    query: query\n  }));\n}\n\nvar _excluded = [\"refetch\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction useLazyDryRun(query) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _useCubeFetch = useCubeFetch('dryRun', _objectSpread(_objectSpread({}, options), {}, {\n    query: query,\n    skip: true\n  })),\n      refetch = _useCubeFetch.refetch,\n      result = _objectWithoutProperties(_useCubeFetch, _excluded);\n\n  return [refetch, result];\n}\n\nfunction useCubeQuery(query) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var mutexRef = useRef({});\n  var isMounted = useIsMounted();\n\n  var _useState = useState(null),\n      _useState2 = _slicedToArray(_useState, 2),\n      currentQuery = _useState2[0],\n      setCurrentQuery = _useState2[1];\n\n  var _useState3 = useState(false),\n      _useState4 = _slicedToArray(_useState3, 2),\n      isLoading = _useState4[0],\n      setLoading = _useState4[1];\n\n  var _useState5 = useState(null),\n      _useState6 = _slicedToArray(_useState5, 2),\n      resultSet = _useState6[0],\n      setResultSet = _useState6[1];\n\n  var _useState7 = useState(null),\n      _useState8 = _slicedToArray(_useState7, 2),\n      progress = _useState8[0],\n      setProgress = _useState8[1];\n\n  var _useState9 = useState(null),\n      _useState10 = _slicedToArray(_useState9, 2),\n      error = _useState10[0],\n      setError = _useState10[1];\n\n  var context = useContext(CubeContext);\n  var subscribeRequest = null;\n\n  var progressCallback = function progressCallback(_ref) {\n    var progressResponse = _ref.progressResponse;\n    return setProgress(progressResponse);\n  };\n\n  function fetch() {\n    return _fetch.apply(this, arguments);\n  }\n\n  function _fetch() {\n    _fetch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var resetResultSetOnChange, cubejsApi, response;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              resetResultSetOnChange = options.resetResultSetOnChange;\n              cubejsApi = options.cubejsApi || (context === null || context === void 0 ? void 0 : context.cubejsApi);\n\n              if (cubejsApi) {\n                _context2.next = 4;\n                break;\n              }\n\n              throw new Error('Cube.js API client is not provided');\n\n            case 4:\n              if (resetResultSetOnChange) {\n                setResultSet(null);\n              }\n\n              setError(null);\n              setLoading(true);\n              _context2.prev = 7;\n              _context2.next = 10;\n              return cubejsApi.load(query, {\n                mutexObj: mutexRef.current,\n                mutexKey: 'query',\n                progressCallback: progressCallback\n              });\n\n            case 10:\n              response = _context2.sent;\n\n              if (isMounted()) {\n                setResultSet(response);\n                setProgress(null);\n              }\n\n              _context2.next = 17;\n              break;\n\n            case 14:\n              _context2.prev = 14;\n              _context2.t0 = _context2[\"catch\"](7);\n\n              if (isMounted()) {\n                setError(_context2.t0);\n                setResultSet(null);\n                setProgress(null);\n              }\n\n            case 17:\n              if (isMounted()) {\n                setLoading(false);\n              }\n\n            case 18:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, null, [[7, 14]]);\n    }));\n    return _fetch.apply(this, arguments);\n  }\n\n  useEffect(function () {\n    var _options$skip = options.skip,\n        skip = _options$skip === void 0 ? false : _options$skip,\n        resetResultSetOnChange = options.resetResultSetOnChange;\n    var cubejsApi = options.cubejsApi || (context === null || context === void 0 ? void 0 : context.cubejsApi);\n\n    if (!cubejsApi) {\n      throw new Error('Cube.js API client is not provided');\n    }\n\n    function loadQuery() {\n      return _loadQuery.apply(this, arguments);\n    }\n\n    function _loadQuery() {\n      _loadQuery = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!(!skip && isQueryPresent(query))) {\n                  _context.next = 20;\n                  break;\n                }\n\n                if (!areQueriesEqual(currentQuery, query)) {\n                  if (resetResultSetOnChange == null || resetResultSetOnChange) {\n                    setResultSet(null);\n                  }\n\n                  setCurrentQuery(query);\n                }\n\n                setError(null);\n                setLoading(true);\n                _context.prev = 4;\n\n                if (!subscribeRequest) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 8;\n                return subscribeRequest.unsubscribe();\n\n              case 8:\n                subscribeRequest = null;\n\n              case 9:\n                if (!options.subscribe) {\n                  _context.next = 13;\n                  break;\n                }\n\n                subscribeRequest = cubejsApi.subscribe(query, {\n                  mutexObj: mutexRef.current,\n                  mutexKey: 'query',\n                  progressCallback: progressCallback\n                }, function (e, result) {\n                  if (isMounted()) {\n                    if (e) {\n                      setError(e);\n                    } else {\n                      setResultSet(result);\n                    }\n\n                    setLoading(false);\n                    setProgress(null);\n                  }\n                });\n                _context.next = 15;\n                break;\n\n              case 13:\n                _context.next = 15;\n                return fetch();\n\n              case 15:\n                _context.next = 20;\n                break;\n\n              case 17:\n                _context.prev = 17;\n                _context.t0 = _context[\"catch\"](4);\n\n                if (isMounted()) {\n                  setError(_context.t0);\n                  setResultSet(null);\n                  setLoading(false);\n                  setProgress(null);\n                }\n\n              case 20:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[4, 17]]);\n      }));\n      return _loadQuery.apply(this, arguments);\n    }\n\n    loadQuery();\n    return function () {\n      if (subscribeRequest) {\n        subscribeRequest.unsubscribe();\n        subscribeRequest = null;\n      }\n    };\n  }, useDeepCompareMemoize([query, Object.keys(query && query.order || {}), options, context]));\n  return {\n    isLoading: isLoading,\n    resultSet: resultSet,\n    error: error,\n    progress: progress,\n    previousQuery: currentQuery,\n    refetch: fetch\n  };\n}\n\nfunction useCubeMeta() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return useCubeFetch('meta', options);\n}\n\nexport { CubeContext, CubeProvider, QueryBuilder, QueryRenderer, QueryRendererWithTotals, useCubeMeta, useCubeQuery, useCubeSql, useDryRun, useLazyDryRun };","map":null,"metadata":{},"sourceType":"module"}