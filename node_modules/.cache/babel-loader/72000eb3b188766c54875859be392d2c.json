{"ast":null,"code":"\"use strict\"; // This file was originally written by @drudru (https://github.com/drudru/ansi_up), MIT, 2011\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nvar ANSI_COLORS = [[{\n  color: \"0, 0, 0\",\n  \"class\": \"ansi-black\"\n}, {\n  color: \"187, 0, 0\",\n  \"class\": \"ansi-red\"\n}, {\n  color: \"0, 187, 0\",\n  \"class\": \"ansi-green\"\n}, {\n  color: \"187, 187, 0\",\n  \"class\": \"ansi-yellow\"\n}, {\n  color: \"0, 0, 187\",\n  \"class\": \"ansi-blue\"\n}, {\n  color: \"187, 0, 187\",\n  \"class\": \"ansi-magenta\"\n}, {\n  color: \"0, 187, 187\",\n  \"class\": \"ansi-cyan\"\n}, {\n  color: \"255,255,255\",\n  \"class\": \"ansi-white\"\n}], [{\n  color: \"85, 85, 85\",\n  \"class\": \"ansi-bright-black\"\n}, {\n  color: \"255, 85, 85\",\n  \"class\": \"ansi-bright-red\"\n}, {\n  color: \"0, 255, 0\",\n  \"class\": \"ansi-bright-green\"\n}, {\n  color: \"255, 255, 85\",\n  \"class\": \"ansi-bright-yellow\"\n}, {\n  color: \"85, 85, 255\",\n  \"class\": \"ansi-bright-blue\"\n}, {\n  color: \"255, 85, 255\",\n  \"class\": \"ansi-bright-magenta\"\n}, {\n  color: \"85, 255, 255\",\n  \"class\": \"ansi-bright-cyan\"\n}, {\n  color: \"255, 255, 255\",\n  \"class\": \"ansi-bright-white\"\n}]];\n\nvar Anser = function () {\n  _createClass(Anser, null, [{\n    key: \"escapeForHtml\",\n\n    /**\n     * Anser.escapeForHtml\n     * Escape the input HTML.\n     *\n     * This does the minimum escaping of text to make it compliant with HTML.\n     * In particular, the '&','<', and '>' characters are escaped. This should\n     * be run prior to `ansiToHtml`.\n     *\n     * @name Anser.escapeForHtml\n     * @function\n     * @param {String} txt The input text (containing the ANSI snippets).\n     * @returns {String} The escaped html.\n     */\n    value: function escapeForHtml(txt) {\n      return new Anser().escapeForHtml(txt);\n    }\n    /**\n     * Anser.linkify\n     * Adds the links in the HTML.\n     *\n     * This replaces any links in the text with anchor tags that display the\n     * link. The links should have at least one whitespace character\n     * surrounding it. Also, you should apply this after you have run\n     * `ansiToHtml` on the text.\n     *\n     * @name Anser.linkify\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The HTML containing the <a> tags (unescaped).\n     */\n\n  }, {\n    key: \"linkify\",\n    value: function linkify(txt) {\n      return new Anser().linkify(txt);\n    }\n    /**\n     * Anser.ansiToHtml\n     * This replaces ANSI terminal escape codes with SPAN tags that wrap the\n     * content.\n     *\n     * This function only interprets ANSI SGR (Select Graphic Rendition) codes\n     * that can be represented in HTML.\n     * For example, cursor movement codes are ignored and hidden from output.\n     * The default style uses colors that are very close to the prescribed\n     * standard. The standard assumes that the text will have a black\n     * background. These colors are set as inline styles on the SPAN tags.\n     *\n     * Another option is to set `use_classes: true` in the options argument.\n     * This will instead set classes on the spans so the colors can be set via\n     * CSS. The class names used are of the format `ansi-*-fg/bg` and\n     * `ansi-bright-*-fg/bg` where `*` is the color name,\n     * i.e black/red/green/yellow/blue/magenta/cyan/white.\n     *\n     * @name Anser.ansiToHtml\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed to the ansiToHTML method.\n     * @returns {String} The HTML output.\n     */\n\n  }, {\n    key: \"ansiToHtml\",\n    value: function ansiToHtml(txt, options) {\n      return new Anser().ansiToHtml(txt, options);\n    }\n    /**\n     * Anser.ansiToJson\n     * Converts ANSI input into JSON output.\n     *\n     * @name Anser.ansiToJson\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed to the ansiToHTML method.\n     * @returns {String} The HTML output.\n     */\n\n  }, {\n    key: \"ansiToJson\",\n    value: function ansiToJson(txt, options) {\n      return new Anser().ansiToJson(txt, options);\n    }\n    /**\n     * Anser.ansiToText\n     * Converts ANSI input into text output.\n     *\n     * @name Anser.ansiToText\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The text output.\n     */\n\n  }, {\n    key: \"ansiToText\",\n    value: function ansiToText(txt) {\n      return new Anser().ansiToText(txt);\n    }\n    /**\n     * Anser\n     * The `Anser` class.\n     *\n     * @name Anser\n     * @function\n     * @returns {Anser}\n     */\n\n  }]);\n\n  function Anser() {\n    _classCallCheck(this, Anser);\n\n    this.fg = this.bg = this.fg_truecolor = this.bg_truecolor = null;\n    this.bright = 0;\n    this.decorations = [];\n  }\n  /**\n   * setupPalette\n   * Sets up the palette.\n   *\n   * @name setupPalette\n   * @function\n   */\n\n\n  _createClass(Anser, [{\n    key: \"setupPalette\",\n    value: function setupPalette() {\n      this.PALETTE_COLORS = []; // Index 0..15 : System color\n\n      for (var i = 0; i < 2; ++i) {\n        for (var j = 0; j < 8; ++j) {\n          this.PALETTE_COLORS.push(ANSI_COLORS[i][j].color);\n        }\n      } // Index 16..231 : RGB 6x6x6\n      // https://gist.github.com/jasonm23/2868981#file-xterm-256color-yaml\n\n\n      var levels = [0, 95, 135, 175, 215, 255];\n\n      var format = function format(r, g, b) {\n        return levels[r] + \", \" + levels[g] + \", \" + levels[b];\n      };\n\n      var r = void 0,\n          g = void 0,\n          b = void 0;\n\n      for (var _r = 0; _r < 6; ++_r) {\n        for (var _g = 0; _g < 6; ++_g) {\n          for (var _b = 0; _b < 6; ++_b) {\n            this.PALETTE_COLORS.push(format(_r, _g, _b));\n          }\n        }\n      } // Index 232..255 : Grayscale\n\n\n      var level = 8;\n\n      for (var _i = 0; _i < 24; ++_i, level += 10) {\n        this.PALETTE_COLORS.push(format(level, level, level));\n      }\n    }\n    /**\n     * escapeForHtml\n     * Escapes the input text.\n     *\n     * @name escapeForHtml\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The escpaed HTML output.\n     */\n\n  }, {\n    key: \"escapeForHtml\",\n    value: function escapeForHtml(txt) {\n      return txt.replace(/[&<>\\\"]/gm, function (str) {\n        return str == \"&\" ? \"&amp;\" : str == '\"' ? \"&quot;\" : str == \"<\" ? \"&lt;\" : str == \">\" ? \"&gt;\" : \"\";\n      });\n    }\n    /**\n     * linkify\n     * Adds HTML link elements.\n     *\n     * @name linkify\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The HTML output containing link elements.\n     */\n\n  }, {\n    key: \"linkify\",\n    value: function linkify(txt) {\n      return txt.replace(/(https?:\\/\\/[^\\s]+)/gm, function (str) {\n        return \"<a href=\\\"\" + str + \"\\\">\" + str + \"</a>\";\n      });\n    }\n    /**\n     * ansiToHtml\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToHtml\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed ot the `process` method.\n     * @returns {String} The HTML output.\n     */\n\n  }, {\n    key: \"ansiToHtml\",\n    value: function ansiToHtml(txt, options) {\n      return this.process(txt, options, true);\n    }\n    /**\n     * ansiToJson\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToJson\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options The options passed ot the `process` method.\n     * @returns {String} The JSON output.\n     */\n\n  }, {\n    key: \"ansiToJson\",\n    value: function ansiToJson(txt, options) {\n      options = options || {};\n      options.json = true;\n      options.clearLine = false;\n      return this.process(txt, options, true);\n    }\n    /**\n     * ansiToText\n     * Converts ANSI input into HTML output.\n     *\n     * @name ansiToText\n     * @function\n     * @param {String} txt The input text.\n     * @returns {String} The text output.\n     */\n\n  }, {\n    key: \"ansiToText\",\n    value: function ansiToText(txt) {\n      return this.process(txt, {}, false);\n    }\n    /**\n     * process\n     * Processes the input.\n     *\n     * @name process\n     * @function\n     * @param {String} txt The input text.\n     * @param {Object} options An object passed to `processChunk` method, extended with:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup\n     */\n\n  }, {\n    key: \"process\",\n    value: function process(txt, options, markup) {\n      var _this = this;\n\n      var self = this;\n      var raw_text_chunks = txt.split(/\\033\\[/);\n      var first_chunk = raw_text_chunks.shift(); // the first chunk is not the result of the split\n\n      if (options === undefined || options === null) {\n        options = {};\n      }\n\n      options.clearLine = /\\r/.test(txt); // check for Carriage Return\n\n      var color_chunks = raw_text_chunks.map(function (chunk) {\n        return _this.processChunk(chunk, options, markup);\n      });\n\n      if (options && options.json) {\n        var first = self.processChunkJson(\"\");\n        first.content = first_chunk;\n        first.clearLine = options.clearLine;\n        color_chunks.unshift(first);\n\n        if (options.remove_empty) {\n          color_chunks = color_chunks.filter(function (c) {\n            return !c.isEmpty();\n          });\n        }\n\n        return color_chunks;\n      } else {\n        color_chunks.unshift(first_chunk);\n      }\n\n      return color_chunks.join(\"\");\n    }\n    /**\n     * processChunkJson\n     * Processes the current chunk into json output.\n     *\n     * @name processChunkJson\n     * @function\n     * @param {String} text The input text.\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup If false, the colors will not be parsed.\n     * @return {Object} The result object:\n     *\n     *  - `content` (String): The text.\n     *  - `fg` (String|null): The foreground color.\n     *  - `bg` (String|null): The background color.\n     *  - `fg_truecolor` (String|null): The foreground true color (if 16m color is enabled).\n     *  - `bg_truecolor` (String|null): The background true color (if 16m color is enabled).\n     *  - `clearLine` (Boolean): `true` if a carriageReturn \\r was fount at end of line.\n     *  - `was_processed` (Bolean): `true` if the colors were processed, `false` otherwise.\n     *  - `isEmpty` (Function): A function returning `true` if the content is empty, or `false` otherwise.\n     *\n     */\n\n  }, {\n    key: \"processChunkJson\",\n    value: function processChunkJson(text, options, markup) {\n      // Are we using classes or styles?\n      options = typeof options == \"undefined\" ? {} : options;\n      var use_classes = options.use_classes = typeof options.use_classes != \"undefined\" && options.use_classes;\n      var key = options.key = use_classes ? \"class\" : \"color\";\n      var result = {\n        content: text,\n        fg: null,\n        bg: null,\n        fg_truecolor: null,\n        bg_truecolor: null,\n        isInverted: false,\n        clearLine: options.clearLine,\n        decoration: null,\n        decorations: [],\n        was_processed: false,\n        isEmpty: function isEmpty() {\n          return !result.content;\n        }\n      }; // Each \"chunk\" is the text after the CSI (ESC + \"[\") and before the next CSI/EOF.\n      //\n      // This regex matches four groups within a chunk.\n      //\n      // The first and third groups match code type.\n      // We supported only SGR command. It has empty first group and \"m\" in third.\n      //\n      // The second group matches all of the number+semicolon command sequences\n      // before the \"m\" (or other trailing) character.\n      // These are the graphics or SGR commands.\n      //\n      // The last group is the text (including newlines) that is colored by\n      // the other group\"s commands.\n\n      var matches = text.match(/^([!\\x3c-\\x3f]*)([\\d;]*)([\\x20-\\x2c]*[\\x40-\\x7e])([\\s\\S]*)/m);\n      if (!matches) return result;\n      var orig_txt = result.content = matches[4];\n      var nums = matches[2].split(\";\"); // We currently support only \"SGR\" (Select Graphic Rendition)\n      // Simply ignore if not a SGR command.\n\n      if (matches[1] !== \"\" || matches[3] !== \"m\") {\n        return result;\n      }\n\n      if (!markup) {\n        return result;\n      }\n\n      var self = this;\n\n      while (nums.length > 0) {\n        var num_str = nums.shift();\n        var num = parseInt(num_str);\n\n        if (isNaN(num) || num === 0) {\n          self.fg = self.bg = null;\n          self.decorations = [];\n        } else if (num === 1) {\n          self.decorations.push(\"bold\");\n        } else if (num === 2) {\n          self.decorations.push(\"dim\"); // Enable code 2 to get string\n        } else if (num === 3) {\n          self.decorations.push(\"italic\");\n        } else if (num === 4) {\n          self.decorations.push(\"underline\");\n        } else if (num === 5) {\n          self.decorations.push(\"blink\");\n        } else if (num === 7) {\n          self.decorations.push(\"reverse\");\n        } else if (num === 8) {\n          self.decorations.push(\"hidden\"); // Enable code 9 to get strikethrough\n        } else if (num === 9) {\n          self.decorations.push(\"strikethrough\");\n          /**\n           * Add several widely used style codes\n           * @see https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters\n           */\n        } else if (num === 21) {\n          self.removeDecoration(\"bold\");\n        } else if (num === 22) {\n          self.removeDecoration(\"bold\");\n          self.removeDecoration(\"dim\");\n        } else if (num === 23) {\n          self.removeDecoration(\"italic\");\n        } else if (num === 24) {\n          self.removeDecoration(\"underline\");\n        } else if (num === 25) {\n          self.removeDecoration(\"blink\");\n        } else if (num === 27) {\n          self.removeDecoration(\"reverse\");\n        } else if (num === 28) {\n          self.removeDecoration(\"hidden\");\n        } else if (num === 29) {\n          self.removeDecoration(\"strikethrough\");\n        } else if (num === 39) {\n          self.fg = null;\n        } else if (num === 49) {\n          self.bg = null; // Foreground color\n        } else if (num >= 30 && num < 38) {\n          self.fg = ANSI_COLORS[0][num % 10][key]; // Foreground bright color\n        } else if (num >= 90 && num < 98) {\n          self.fg = ANSI_COLORS[1][num % 10][key]; // Background color\n        } else if (num >= 40 && num < 48) {\n          self.bg = ANSI_COLORS[0][num % 10][key]; // Background bright color\n        } else if (num >= 100 && num < 108) {\n          self.bg = ANSI_COLORS[1][num % 10][key];\n        } else if (num === 38 || num === 48) {\n          // extend color (38=fg, 48=bg)\n          var is_foreground = num === 38;\n\n          if (nums.length >= 1) {\n            var mode = nums.shift();\n\n            if (mode === \"5\" && nums.length >= 1) {\n              // palette color\n              var palette_index = parseInt(nums.shift());\n\n              if (palette_index >= 0 && palette_index <= 255) {\n                if (!use_classes) {\n                  if (!this.PALETTE_COLORS) {\n                    self.setupPalette();\n                  }\n\n                  if (is_foreground) {\n                    self.fg = this.PALETTE_COLORS[palette_index];\n                  } else {\n                    self.bg = this.PALETTE_COLORS[palette_index];\n                  }\n                } else {\n                  var klass = palette_index >= 16 ? \"ansi-palette-\" + palette_index : ANSI_COLORS[palette_index > 7 ? 1 : 0][palette_index % 8][\"class\"];\n\n                  if (is_foreground) {\n                    self.fg = klass;\n                  } else {\n                    self.bg = klass;\n                  }\n                }\n              }\n            } else if (mode === \"2\" && nums.length >= 3) {\n              // true color\n              var r = parseInt(nums.shift());\n              var g = parseInt(nums.shift());\n              var b = parseInt(nums.shift());\n\n              if (r >= 0 && r <= 255 && g >= 0 && g <= 255 && b >= 0 && b <= 255) {\n                var color = r + \", \" + g + \", \" + b;\n\n                if (!use_classes) {\n                  if (is_foreground) {\n                    self.fg = color;\n                  } else {\n                    self.bg = color;\n                  }\n                } else {\n                  if (is_foreground) {\n                    self.fg = \"ansi-truecolor\";\n                    self.fg_truecolor = color;\n                  } else {\n                    self.bg = \"ansi-truecolor\";\n                    self.bg_truecolor = color;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n\n      if (self.fg === null && self.bg === null && self.decorations.length === 0) {\n        return result;\n      } else {\n        var styles = [];\n        var classes = [];\n        var data = {};\n        result.fg = self.fg;\n        result.bg = self.bg;\n        result.fg_truecolor = self.fg_truecolor;\n        result.bg_truecolor = self.bg_truecolor;\n        result.decorations = self.decorations;\n        result.decoration = self.decorations.slice(-1).pop() || null;\n        result.was_processed = true;\n        return result;\n      }\n    }\n    /**\n     * processChunk\n     * Processes the current chunk of text.\n     *\n     * @name processChunk\n     * @function\n     * @param {String} text The input text.\n     * @param {Object} options An object containing the following fields:\n     *\n     *  - `json` (Boolean): If `true`, the result will be an object.\n     *  - `use_classes` (Boolean): If `true`, HTML classes will be appended to the HTML output.\n     *\n     * @param {Boolean} markup If false, the colors will not be parsed.\n     * @return {Object|String} The result (object if `json` is wanted back or string otherwise).\n     */\n\n  }, {\n    key: \"processChunk\",\n    value: function processChunk(text, options, markup) {\n      var _this2 = this;\n\n      options = options || {};\n      var jsonChunk = this.processChunkJson(text, options, markup);\n      var use_classes = options.use_classes; // \"reverse\" decoration reverses foreground and background colors\n\n      jsonChunk.decorations = jsonChunk.decorations.filter(function (decoration) {\n        if (decoration === \"reverse\") {\n          // when reversing, missing colors are defaulted to black (bg) and white (fg)\n          if (!jsonChunk.fg) {\n            jsonChunk.fg = ANSI_COLORS[0][7][use_classes ? \"class\" : \"color\"];\n          }\n\n          if (!jsonChunk.bg) {\n            jsonChunk.bg = ANSI_COLORS[0][0][use_classes ? \"class\" : \"color\"];\n          }\n\n          var tmpFg = jsonChunk.fg;\n          jsonChunk.fg = jsonChunk.bg;\n          jsonChunk.bg = tmpFg;\n          var tmpFgTrue = jsonChunk.fg_truecolor;\n          jsonChunk.fg_truecolor = jsonChunk.bg_truecolor;\n          jsonChunk.bg_truecolor = tmpFgTrue;\n          jsonChunk.isInverted = true;\n          return false;\n        }\n\n        return true;\n      });\n\n      if (options.json) {\n        return jsonChunk;\n      }\n\n      if (jsonChunk.isEmpty()) {\n        return \"\";\n      }\n\n      if (!jsonChunk.was_processed) {\n        return jsonChunk.content;\n      }\n\n      var colors = [];\n      var decorations = [];\n      var textDecorations = [];\n      var data = {};\n\n      var render_data = function render_data(data) {\n        var fragments = [];\n        var key = void 0;\n\n        for (key in data) {\n          if (data.hasOwnProperty(key)) {\n            fragments.push(\"data-\" + key + \"=\\\"\" + _this2.escapeForHtml(data[key]) + \"\\\"\");\n          }\n        }\n\n        return fragments.length > 0 ? \" \" + fragments.join(\" \") : \"\";\n      };\n\n      if (jsonChunk.isInverted) {\n        data[\"ansi-is-inverted\"] = \"true\";\n      }\n\n      if (jsonChunk.fg) {\n        if (use_classes) {\n          colors.push(jsonChunk.fg + \"-fg\");\n\n          if (jsonChunk.fg_truecolor !== null) {\n            data[\"ansi-truecolor-fg\"] = jsonChunk.fg_truecolor;\n            jsonChunk.fg_truecolor = null;\n          }\n        } else {\n          colors.push(\"color:rgb(\" + jsonChunk.fg + \")\");\n        }\n      }\n\n      if (jsonChunk.bg) {\n        if (use_classes) {\n          colors.push(jsonChunk.bg + \"-bg\");\n\n          if (jsonChunk.bg_truecolor !== null) {\n            data[\"ansi-truecolor-bg\"] = jsonChunk.bg_truecolor;\n            jsonChunk.bg_truecolor = null;\n          }\n        } else {\n          colors.push(\"background-color:rgb(\" + jsonChunk.bg + \")\");\n        }\n      }\n\n      jsonChunk.decorations.forEach(function (decoration) {\n        // use classes\n        if (use_classes) {\n          decorations.push(\"ansi-\" + decoration);\n          return;\n        } // use styles\n\n\n        if (decoration === \"bold\") {\n          decorations.push(\"font-weight:bold\");\n        } else if (decoration === \"dim\") {\n          decorations.push(\"opacity:0.5\");\n        } else if (decoration === \"italic\") {\n          decorations.push(\"font-style:italic\");\n        } else if (decoration === \"hidden\") {\n          decorations.push(\"visibility:hidden\");\n        } else if (decoration === \"strikethrough\") {\n          textDecorations.push(\"line-through\");\n        } else {\n          // underline and blink are treated here\n          textDecorations.push(decoration);\n        }\n      });\n\n      if (textDecorations.length) {\n        decorations.push(\"text-decoration:\" + textDecorations.join(\" \"));\n      }\n\n      if (use_classes) {\n        return \"<span class=\\\"\" + colors.concat(decorations).join(\" \") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n      } else {\n        return \"<span style=\\\"\" + colors.concat(decorations).join(\";\") + \"\\\"\" + render_data(data) + \">\" + jsonChunk.content + \"</span>\";\n      }\n    }\n  }, {\n    key: \"removeDecoration\",\n    value: function removeDecoration(decoration) {\n      var index = this.decorations.indexOf(decoration);\n\n      if (index >= 0) {\n        this.decorations.splice(index, 1);\n      }\n    }\n  }]);\n\n  return Anser;\n}();\n\nmodule.exports = Anser;","map":null,"metadata":{},"sourceType":"script"}