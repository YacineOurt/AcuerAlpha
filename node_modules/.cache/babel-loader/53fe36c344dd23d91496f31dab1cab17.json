{"ast":null,"code":"import _objectSpread from \"/home/yacine/Pro/alpha/AcuerApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport _classCallCheck from \"/home/yacine/Pro/alpha/AcuerApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/yacine/Pro/alpha/AcuerApp/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { transformToViewState, applyViewStateToTransform, cloneTransform } from '../utils/transform';\nimport { normalizeStyle } from '../utils/style-utils';\nimport { deepEqual } from '../utils/deep-equal';\nvar pointerEvents = {\n  mousedown: 'onMouseDown',\n  mouseup: 'onMouseUp',\n  mouseover: 'onMouseOver',\n  mousemove: 'onMouseMove',\n  click: 'onClick',\n  dblclick: 'onDblClick',\n  mouseenter: 'onMouseEnter',\n  mouseleave: 'onMouseLeave',\n  mouseout: 'onMouseOut',\n  contextmenu: 'onContextMenu',\n  touchstart: 'onTouchStart',\n  touchend: 'onTouchEnd',\n  touchmove: 'onTouchMove',\n  touchcancel: 'onTouchCancel'\n};\nvar cameraEvents = {\n  movestart: 'onMoveStart',\n  move: 'onMove',\n  moveend: 'onMoveEnd',\n  dragstart: 'onDragStart',\n  drag: 'onDrag',\n  dragend: 'onDragEnd',\n  zoomstart: 'onZoomStart',\n  zoom: 'onZoom',\n  zoomend: 'onZoomEnd',\n  rotatestart: 'onRotateStart',\n  rotate: 'onRotate',\n  rotateend: 'onRotateEnd',\n  pitchstart: 'onPitchStart',\n  pitch: 'onPitch',\n  pitchend: 'onPitchEnd'\n};\nvar otherEvents = {\n  wheel: 'onWheel',\n  boxzoomstart: 'onBoxZoomStart',\n  boxzoomend: 'onBoxZoomEnd',\n  boxzoomcancel: 'onBoxZoomCancel',\n  resize: 'onResize',\n  load: 'onLoad',\n  render: 'onRender',\n  idle: 'onIdle',\n  remove: 'onRemove',\n  data: 'onData',\n  styledata: 'onStyleData',\n  sourcedata: 'onSourceData',\n  error: 'onError'\n};\nvar settingNames = ['minZoom', 'maxZoom', 'minPitch', 'maxPitch', 'maxBounds', 'projection', 'renderWorldCopies'];\nvar handlerNames = ['scrollZoom', 'boxZoom', 'dragRotate', 'dragPan', 'keyboard', 'doubleClickZoom', 'touchZoomRotate', 'touchPitch'];\n/**\n * A wrapper for mapbox-gl's Map class\n */\n\nvar Mapbox = /*#__PURE__*/function () {\n  function Mapbox(MapClass, props, container) {\n    var _this = this;\n\n    _classCallCheck(this, Mapbox);\n\n    // mapboxgl.Map instance. Not using type here because we are accessing\n    // private members and methods\n    this._map = null; // Internal states\n\n    this._internalUpdate = false;\n    this._inRender = false;\n    this._hoveredFeatures = null;\n    this._deferredEvents = {\n      move: false,\n      zoom: false,\n      pitch: false,\n      rotate: false\n    };\n\n    this._onEvent = function (e) {\n      // @ts-ignore\n      var cb = _this.props[otherEvents[e.type]];\n\n      if (cb) {\n        cb(e);\n      }\n    };\n\n    this._onPointerEvent = function (e) {\n      if (e.type === 'mousemove' || e.type === 'mouseout') {\n        _this._updateHover(e);\n      } // @ts-ignore\n\n\n      var cb = _this.props[pointerEvents[e.type]];\n\n      if (cb) {\n        if (_this.props.interactiveLayerIds && e.type !== 'mouseover' && e.type !== 'mouseout') {\n          var features = _this._hoveredFeatures || _this._map.queryRenderedFeatures(e.point, {\n            layers: _this.props.interactiveLayerIds\n          });\n\n          if (!features.length) {\n            return;\n          }\n\n          e.features = features;\n        }\n\n        cb(e);\n        delete e.features;\n      }\n    };\n\n    this._onCameraEvent = function (e) {\n      if (!_this._internalUpdate) {\n        // @ts-ignore\n        var cb = _this.props[cameraEvents[e.type]];\n\n        if (cb) {\n          cb(e);\n        }\n      }\n\n      if (e.type in _this._deferredEvents) {\n        _this._deferredEvents[e.type] = false;\n      }\n    };\n\n    this._MapClass = MapClass;\n    this.props = props;\n\n    this._initialize(container);\n  }\n\n  _createClass(Mapbox, [{\n    key: \"setProps\",\n    value: function setProps(props) {\n      var oldProps = this.props;\n      this.props = props;\n\n      var settingsChanged = this._updateSettings(props, oldProps);\n\n      if (settingsChanged) {\n        this._renderTransform = cloneTransform(this._map.transform);\n      }\n\n      var sizeChanged = this._updateSize(props);\n\n      var viewStateChanged = this._updateViewState(props, true);\n\n      this._updateStyle(props, oldProps);\n\n      this._updateStyleComponents(props, oldProps);\n\n      this._updateHandlers(props, oldProps); // If 1) view state has changed to match props and\n      //    2) the props change is not triggered by map events,\n      // it's driven by an external state change. Redraw immediately\n\n\n      if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) {\n        this.redraw();\n      }\n    }\n  }, {\n    key: \"_initialize\",\n\n    /* eslint-disable complexity,max-statements */\n    value: function _initialize(container) {\n      var _this2 = this;\n\n      var props = this.props;\n\n      var mapOptions = _objectSpread({}, props, props.initialViewState, {\n        accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,\n        container: container,\n        style: normalizeStyle(props.mapStyle)\n      });\n\n      var viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;\n      Object.assign(mapOptions, {\n        center: [viewState.longitude || 0, viewState.latitude || 0],\n        zoom: viewState.zoom || 0,\n        pitch: viewState.pitch || 0,\n        bearing: viewState.bearing || 0\n      });\n\n      if (props.gl) {\n        // eslint-disable-next-line\n        var getContext = HTMLCanvasElement.prototype.getContext; // Hijack canvas.getContext to return our own WebGLContext\n        // This will be called inside the mapboxgl.Map constructor\n        // @ts-expect-error\n\n        HTMLCanvasElement.prototype.getContext = function () {\n          // Unhijack immediately\n          HTMLCanvasElement.prototype.getContext = getContext;\n          return props.gl;\n        };\n      }\n\n      var map = new this._MapClass(mapOptions); // Props that are not part of constructor options\n\n      if (viewState.padding) {\n        map.setPadding(viewState.padding);\n      }\n\n      if (props.cursor) {\n        map.getCanvas().style.cursor = props.cursor;\n      }\n\n      this._renderTransform = cloneTransform(map.transform); // Hack\n      // Insert code into map's render cycle\n\n      var renderMap = map._render;\n\n      map._render = function (arg) {\n        _this2._inRender = true;\n        renderMap.call(map, arg);\n        _this2._inRender = false;\n      };\n\n      var runRenderTaskQueue = map._renderTaskQueue.run;\n\n      map._renderTaskQueue.run = function (arg) {\n        runRenderTaskQueue.call(map._renderTaskQueue, arg);\n\n        _this2._onBeforeRepaint();\n      };\n\n      map.on('render', function () {\n        return _this2._onAfterRepaint();\n      }); // Insert code into map's event pipeline\n\n      var fireEvent = map.fire;\n      map.fire = this._fireEvent.bind(this, fireEvent); // add listeners\n\n      map.on('resize', function () {\n        _this2._renderTransform.resize(map.transform.width, map.transform.height);\n      });\n      map.on('styledata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n      map.on('sourcedata', function () {\n        return _this2._updateStyleComponents(_this2.props, {});\n      });\n\n      for (var eventName in pointerEvents) {\n        map.on(eventName, this._onPointerEvent);\n      }\n\n      for (var _eventName in cameraEvents) {\n        map.on(_eventName, this._onCameraEvent);\n      }\n\n      for (var _eventName2 in otherEvents) {\n        map.on(_eventName2, this._onEvent);\n      }\n\n      this._map = map;\n    }\n    /* eslint-enable complexity,max-statements */\n\n  }, {\n    key: \"recycle\",\n    value: function recycle() {\n      Mapbox.savedMaps.push(this);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._map.remove();\n    } // Force redraw the map now. Typically resize() and jumpTo() is reflected in the next\n    // render cycle, which is managed by Mapbox's animation loop.\n    // This removes the synchronization issue caused by requestAnimationFrame.\n\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      var map = this._map; // map._render will throw error if style does not exist\n      // https://github.com/mapbox/mapbox-gl-js/blob/fb9fc316da14e99ff4368f3e4faa3888fb43c513\n      //   /src/ui/map.js#L1834\n\n      if (!this._inRender && map.style) {\n        // cancel the scheduled update\n        if (map._frame) {\n          map._frame.cancel();\n\n          map._frame = null;\n        } // the order is important - render() may schedule another update\n\n\n        map._render();\n      }\n    }\n    /* Trigger map resize if size is controlled\n       @param {object} nextProps\n       @returns {bool} true if size has changed\n     */\n\n  }, {\n    key: \"_updateSize\",\n    value: function _updateSize(nextProps) {\n      // Check if size is controlled\n      var viewState = nextProps.viewState;\n\n      if (viewState) {\n        var map = this._map;\n\n        if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {\n          map.resize();\n          return true;\n        }\n      }\n\n      return false;\n    } // Adapted from map.jumpTo\n\n    /* Update camera to match props\n       @param {object} nextProps\n       @param {bool} triggerEvents - should fire camera events\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateViewState\",\n    value: function _updateViewState(nextProps, triggerEvents) {\n      if (this._internalUpdate) {\n        return false;\n      }\n\n      var map = this._map;\n      var tr = this._renderTransform; // Take a snapshot of the transform before mutation\n\n      var zoom = tr.zoom,\n          pitch = tr.pitch,\n          bearing = tr.bearing;\n      var changed = applyViewStateToTransform(tr, _objectSpread({}, transformToViewState(map.transform), nextProps));\n\n      if (changed && triggerEvents) {\n        var deferredEvents = this._deferredEvents; // Delay DOM control updates to the next render cycle\n\n        deferredEvents.move = true;\n        deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);\n        deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);\n        deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);\n      } // Avoid manipulating the real transform when interaction/animation is ongoing\n      // as it would interfere with Mapbox's handlers\n\n\n      if (!map.isMoving()) {\n        applyViewStateToTransform(map.transform, nextProps);\n      }\n\n      return changed;\n    }\n    /* Update camera constraints and projection settings to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateSettings\",\n    value: function _updateSettings(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator = _createForOfIteratorHelper(settingNames),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var propName = _step.value;\n\n          if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {\n            changed = true;\n            map[\"set\".concat(propName[0].toUpperCase()).concat(propName.slice(1))](nextProps[propName]);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return changed;\n    }\n    /* Update map style to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if style is changed\n     */\n\n  }, {\n    key: \"_updateStyle\",\n    value: function _updateStyle(nextProps, currProps) {\n      if (nextProps.cursor !== currProps.cursor) {\n        this._map.getCanvas().style.cursor = nextProps.cursor;\n      }\n\n      if (nextProps.mapStyle !== currProps.mapStyle) {\n        var options = {\n          diff: nextProps.styleDiffing\n        };\n\n        if ('localIdeographFontFamily' in nextProps) {\n          options.localIdeographFontFamily = nextProps.localIdeographFontFamily;\n        }\n\n        this._map.setStyle(normalizeStyle(nextProps.mapStyle), options);\n\n        return true;\n      }\n\n      return false;\n    }\n    /* Update fog, light and terrain to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateStyleComponents\",\n    value: function _updateStyleComponents(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      if (map.style.loaded()) {\n        if ('light' in nextProps && !deepEqual(nextProps.light, currProps.light)) {\n          changed = true;\n          map.setLight(nextProps.light);\n        }\n\n        if ('fog' in nextProps && !deepEqual(nextProps.fog, currProps.fog)) {\n          changed = true;\n          map.setFog(nextProps.fog);\n        }\n\n        if ('terrain' in nextProps && !deepEqual(nextProps.terrain, currProps.terrain)) {\n          if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {\n            changed = true;\n            map.setTerrain(nextProps.terrain);\n          }\n        }\n      }\n\n      return changed;\n    }\n    /* Update interaction handlers to match props\n       @param {object} nextProps\n       @param {object} currProps\n       @returns {bool} true if anything is changed\n     */\n\n  }, {\n    key: \"_updateHandlers\",\n    value: function _updateHandlers(nextProps, currProps) {\n      var map = this._map;\n      var changed = false;\n\n      var _iterator2 = _createForOfIteratorHelper(handlerNames),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var propName = _step2.value;\n          var newValue = nextProps[propName];\n\n          if (!deepEqual(newValue, currProps[propName])) {\n            changed = true;\n\n            if (newValue) {\n              map[propName].enable(newValue);\n            } else {\n              map[propName].disable();\n            }\n          }\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      return changed;\n    }\n  }, {\n    key: \"_updateHover\",\n    value: function _updateHover(e) {\n      var _a;\n\n      var props = this.props;\n      var shouldTrackHoveredFeatures = props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave);\n\n      if (shouldTrackHoveredFeatures) {\n        var eventType = e.type;\n        var wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;\n        var features;\n\n        if (eventType === 'mousemove') {\n          try {\n            features = this._map.queryRenderedFeatures(e.point, {\n              layers: props.interactiveLayerIds\n            });\n          } catch (_b) {\n            features = [];\n          }\n        } else {\n          features = [];\n        }\n\n        var isHovering = features.length > 0;\n\n        if (!isHovering && wasHovering) {\n          e.type = 'mouseleave';\n\n          this._onPointerEvent(e);\n        }\n\n        this._hoveredFeatures = features;\n\n        if (isHovering && !wasHovering) {\n          e.type = 'mouseenter';\n\n          this._onPointerEvent(e);\n        }\n\n        e.type = eventType;\n      } else {\n        this._hoveredFeatures = null;\n      }\n    }\n  }, {\n    key: \"_fireEvent\",\n    value: function _fireEvent(baseFire, event, properties) {\n      var map = this._map;\n      var tr = map.transform;\n      var eventType = typeof event === 'string' ? event : event.type;\n\n      if (eventType === 'move') {\n        this._updateViewState(this.props, false);\n      }\n\n      if (eventType in cameraEvents) {\n        if (typeof event === 'object') {\n          event.viewState = transformToViewState(tr);\n        }\n\n        if (this._map.isMoving()) {\n          // Replace map.transform with ours during the callbacks\n          map.transform = this._renderTransform;\n          baseFire.call(map, event, properties);\n          map.transform = tr;\n          return map;\n        }\n      }\n\n      baseFire.call(map, event, properties);\n      return map;\n    } // All camera manipulations are complete, ready to repaint\n\n  }, {\n    key: \"_onBeforeRepaint\",\n    value: function _onBeforeRepaint() {\n      var _this3 = this;\n\n      var map = this._map; // If there are camera changes driven by props, invoke camera events so that DOM controls are synced\n\n      this._internalUpdate = true;\n\n      for (var eventType in this._deferredEvents) {\n        if (this._deferredEvents[eventType]) {\n          map.fire(eventType);\n        }\n      }\n\n      this._internalUpdate = false;\n      var tr = this._map.transform; // Make sure camera matches the current props\n\n      this._map.transform = this._renderTransform;\n      this._map.painter.transform = this._renderTransform;\n\n      this._onAfterRepaint = function () {\n        // Terrain is updated during render\n        if (tr.elevation = _this3._renderTransform.elevation) {\n          tr.updateElevation(false);\n        } // Restores camera state before render/load events are fired\n\n\n        _this3._map.transform = tr;\n      };\n    }\n  }, {\n    key: \"map\",\n    get: function get() {\n      return this._map;\n    }\n  }, {\n    key: \"transform\",\n    get: function get() {\n      return this._renderTransform;\n    }\n  }], [{\n    key: \"reuse\",\n    value: function reuse(props, container) {\n      var that = Mapbox.savedMaps.pop();\n\n      if (!that) {\n        return null;\n      }\n\n      var map = that.map; // When reusing the saved map, we need to reparent the map(canvas) and other child nodes\n      // intoto the new container from the props.\n      // Step1: reparenting child nodes from old container to new container\n\n      var oldContainer = map.getContainer();\n      container.className = oldContainer.className;\n\n      while (oldContainer.childNodes.length > 0) {\n        container.appendChild(oldContainer.childNodes[0]);\n      } // Step2: replace the internal container with new container from the react component\n      // @ts-ignore\n\n\n      map._container = container; // Step 3: apply new props\n\n      if (props.initialViewState) {\n        that._updateViewState(props.initialViewState, false);\n      }\n\n      map.resize();\n      that.setProps(_objectSpread({}, props, {\n        styleDiffing: false\n      })); // Simulate load event\n\n      if (map.isStyleLoaded()) {\n        map.fire('load');\n      } else {\n        map.once('styledata', function () {\n          return map.fire('load');\n        });\n      }\n\n      return that;\n    }\n  }]);\n\n  return Mapbox;\n}();\n\nexport { Mapbox as default };\nMapbox.savedMaps = [];\n/**\n * Access token can be provided via one of:\n *   mapboxAccessToken prop\n *   access_token query parameter\n *   MapboxAccessToken environment variable\n *   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable\n * @returns access token\n */\n\nfunction getAccessTokenFromEnv() {\n  var accessToken = null;\n  /* global location, process */\n\n  if (typeof location !== 'undefined') {\n    var match = /access_token=([^&\\/]*)/.exec(location.search);\n    accessToken = match && match[1];\n  } // Note: This depends on bundler plugins (e.g. webpack) importing environment correctly\n\n\n  try {\n    accessToken = accessToken || process.env.MapboxAccessToken;\n  } catch (_a) {// ignore\n  }\n\n  try {\n    accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;\n  } catch (_b) {// ignore\n  }\n\n  return accessToken;\n}","map":null,"metadata":{},"sourceType":"module"}